{"themeConfig":{"themeName":"gridea-theme-expert-next","postPageSize":12,"archivesPageSize":50,"siteName":"Useless Blogs","siteDescription":"？","footerInfo":"Powered by <a href=\"https://github.com/getgridea/gridea\" target=\"_blank\">Gridea</a>","showFeatureImage":true,"domain":"https://WRuperD.github.io","postUrlFormat":"SLUG","tagUrlFormat":"SHORT_ID","dateFormat":"YYYY-MM-DD","feedFullText":true,"feedCount":11,"archivesPath":"archives","postPath":"post","tagPath":"tag"},"posts":[{"abstract":"","content":"迟早会写的。 ","tags":[],"title":"NOIp 不该怎么考","feature":"","link":"https://WRuperD.github.io/post/noip-bu-gai-zen-me-kao/","stats":{"text":"1 min read","time":1000,"words":5,"minutes":1},"date":"2024-11-29 20:53:44","dateFormat":"2024-11-29"},{"abstract":"","content":"膜拜 yhm. A 最神秘的一集。讲讲我的垃圾做法。 看到 还题面就告诉你要 bitset,时限还是两秒钟，出题人直接演都不带演的，肯定是要你去疯狂的平衡一些东西然后套上 bitset 优化！ m≤200m \\leq 200m≤200 这个就直接对于每一位去看前缀和就可以了，时间复杂度 O(nm+mk)O(nm+mk)O(nm+mk)。 namespace subtask1{ int s[MAX]; void solve(){ for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ if(a[to(i, j)]) s[to(i, j)] = 1; if(i == 1) continue; s[to(i, j)] += s[to(i - 1, j)]; } } int k = read(); int X = read(), Y = read(), Z = read(); int l = 1, r = n; int A = 1, B = n; int ret = 0; while(k--){ int ans = 0; for(int i = 1; i &lt;= m; i++){ int cnt = s[to(r, i)] - s[to(l - 1, i)]; if(cnt == 0 or cnt == r - l + 1){ ans++; } } ret += ans; A = (A * X + ans * Y + Z) % n + 1; B = (B * Y + ans * Z + X) % n + 1; l = min(A, B), r = max(A, B); } write(ret), endl; } } n≤400n \\leq 400n≤400 这个也不难。有用的询问只有至多 n2n^2n2 个所以 kkk 看着大实际小。那么你直接搞一个 O(n2mω)O({n^2m\\over \\omega})O(ωn2m​) 的 bitset 优化就搞完 namespace subtask2{ bitset &lt;100001&gt; bt[405]; bitset &lt;100001&gt; bt2[405]; int ans[405][405]; void solve(){ for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ bt[i][j] = a[to(i, j)]; bt2[i][j] = (a[to(i, j)] ^ 1); } } for(int i = 1; i &lt;= n; i++){ bitset &lt;100001&gt; now; for(int j = i; j &gt;= 1; j--){ now = now | bt[j]; ans[j][i] += (m - now.count()); } } for(int i = 1; i &lt;= n; i++){ bitset &lt;100001&gt; now; for(int j = i; j &gt;= 1; j--){ now = now | bt2[j]; ans[j][i] += (m - now.count()); } } int k = read(); int X = read(), Y = read(), Z = read(); int l = 1, r = n; int A = 1, B = n; int ret = 0; while(k--){ int Ans = ans[l][r]; ret += Ans; // write(l), put(), write(r), put(), write(Ans), endl; A = (A * X + Ans * Y + Z) % n + 1; B = (B * Y + Ans * Z + X) % n + 1; l = min(A, B), r = max(A, B); } write(ret), endl; } } n,m≤5000n,m \\leq 5000n,m≤5000 这下 n,mn,mn,m 都不太大了。那你直接搞一个 st 表套 bitset 优化一下。搞搞搞，直接就做到了 O(nlog⁡nmω)O({n \\log n m \\over \\omega})O(ωnlognm​) 的复杂度。同时这时候空间也不会超。 namespace subtask3{ const int MAX2 = 5e3 + 10; bitset &lt;2505&gt; f[14][MAX2]; bitset &lt;2505&gt; f2[14][MAX2]; int lg2[MAX]; void solve(){ for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ f[0][i][j] = a[to(i, j)]; f2[0][i][j] = (a[to(i, j)] ^ 1); } } for(int i = 1; i &lt; 14; i++){ for(int j = 1; j + (1ll &lt;&lt; i) - 1 &lt;= n; j++){ f[i][j] = f[i - 1][j] | f[i - 1][j + (1ll &lt;&lt; (i - 1))]; } } for(int i = 1; i &lt; 14; i++){ for(int j = 1; j + (1ll &lt;&lt; i) - 1 &lt;= n; j++){ f2[i][j] = f2[i - 1][j] | f2[i - 1][j + (1ll &lt;&lt; (i - 1))]; } } for(int i = 2; i &lt;= n; i++){ lg2[i] = lg2[i &gt;&gt; 1] + 1; } int k = read(); int X = read(), Y = read(), Z = read(); int l = 1, r = n; int A = 1, B = n; int ret = 0; while(k--){ int Ans = 0; int len = (r - l + 1); len = lg2[len]; Ans += m - (f[len][l] | f[len][r - (1ll &lt;&lt; len) + 1]).count(); Ans += m - (f2[len][l] | f2[len][r - (1ll &lt;&lt; len) + 1]).count(); // int Ans = ans[l][r]; ret += Ans; A = (A * X + Ans * Y + Z) % n + 1; B = (B * Y + Ans * Z + X) % n + 1; l = min(A, B), r = max(A, B); } write(ret), endl; } } 然后你就成功在 T1 上面浪费了 1h。 ","tags":[],"title":"Public NOIP Round #8 (Div. 1, 提高) 题解","feature":"","link":"https://WRuperD.github.io/post/public-noip-round-8-div-1-ti-gao-ti-jie/","stats":{"text":"5 min read","time":270000,"words":805,"minutes":5},"date":"2024-11-23 14:36:41","dateFormat":"2024-11-23"},{"abstract":"","content":" 一些 CodeForces 题目的简要题解。 CF1805D A Wide, Wide Graph *1900 有诈骗题那味了。不难发现/证明一个点不与其他点联通当且仅当它没有出边。换根 dp 求出以每个点为根的最大深度即可。 点击查看代码 #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 5e5 + 10; vector &lt;int&gt; g[MAX]; int f[MAX], f3[MAX]; int f2[MAX]; void dfs(int u, int fa){ for(int v : g[u]){ if(v == fa) continue; dfs(v, u); if(f[v] + 1 &gt; f[u]){ f3[u] = f[u]; f[u] = f[v] + 1; }else{ f3[u] = max(f3[u], f[v] + 1); } } } void dfs2(int u, int fa, int premx){ f2[u] = max(f[u], premx); for(int v : g[u]){ if(v == fa) continue; if(f[v] + 1 == f[u]){ dfs2(v, u, max(premx + 1, f3[u] + 1)); }else{ dfs2(v, u, max(premx + 1, f[u] + 1)); } } } int ret[MAX]; void solve(){ int n = read(); for(int i = 1; i &lt; n; i++){ int u = read(), v = read(); g[u].pb(v), g[v].pb(u); } dfs(1, 1); f2[1] = f[1]; dfs2(1, 1, -inf); for(int i = 1; i &lt;= n; i++) ret[f2[i] + 1]++; int now = 1; for(int i = 1; i &lt;= n; i++){ now += ret[i]; now = min(now, n); write(now), put(); } endl; } signed main(){ int t = 1; while(t--) solve(); return 0; } CF1819C The Fox and the Complete Tree Traversal *2400 简单题。首先链肯定可以解决（黑白染色），通过手玩满多叉树的情况不难发现 你在链上面挂深度 ≥2\\geq 2≥2 的子树一定无解。否则一样黑白染色即可。 点击查看代码 // Problem: The Fox and the Complete Tree Traversal // URL: https://www.luogu.com.cn/problem/CF1819C // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 2e5 + 10; vector &lt;int&gt; g[MAX]; int dis[MAX], pre[MAX]; void dfs(int u, int fa){ for(int v : g[u]){ if(v == fa) continue; dis[v] = dis[u] + 1; pre[v] = u; dfs(v, u); } } bool vis[MAX]; int cnt; int work(int u, int fa){ for(int v : g[u]) if(v != fa) return work(v, u) + 1; return 1; } vector &lt;int&gt; A, B; void solve(){ int n = read(); for(int i = 1; i &lt; n; i++){ int u = read(), v = read(); g[u].pb(v), g[v].pb(u); } dfs(1, 1); int rt = 0; for(int i = 1; i &lt;= n; i++) if(dis[i] &gt; dis[rt]) rt = i; dfs(rt, rt); int rt2 = 0; for(int i = 1; i &lt;= n; i++) if(dis[rt2] &lt; dis[i]) rt2 = i; int now = rt2; vector &lt;int&gt; g2; g2.pb(now); vis[now] = 1; while(now != rt){ now = pre[now]; g2.pb(now); vis[now] = 1; } for(int i = 1; i &lt;= n; i++){ if(!vis[i]) continue; cnt = 0; for(int v : g[i]){ if(!vis[v]) cnt = max(cnt, work(v, i)); } if(cnt &gt;= 2){ puts(&quot;No&quot;); exit(0); } } for(int i = 0; i &lt; g2.size(); i++){ int u = g2[i]; if(i % 2){ A.pb(u); for(int v : g[u]) if(!vis[v]) B.pb(v); }else{ B.pb(u); for(int v : g[u]) if(!vis[v]) A.pb(v); } } puts(&quot;Yes&quot;); reverse(B.begin(), B.end()); for(int i = 0; i &lt; A.size(); i++) write(A[i]), put(); for(int i = 0; i &lt; B.size(); i++) write(B[i]), put(); endl; } signed main(){ int t = 1; while(t--) solve(); return 0; } CF2026E Best Subsequence *2500 考虑网络流，每个 aia_iai​ 向他的 111 进制位连正无穷的边。源点向 aia_iai​ 连流量为 1 的边，进制位向汇点连流量为 1 的边。然后就是最小割。 点击查看代码 // Problem: Best Subsequence // URL: https://www.luogu.com.cn/problem/CF2026E // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 1010; int psz = 2; struct flow{ struct node{ int v, w, cp; }; vector &lt;node&gt; g[MAX]; int dis[MAX]; bool bfs(int s, int t){ for(int i = 1; i &lt;= psz; i++) dis[i] = inf; dis[s] = 0; queue &lt;int&gt; q; q.push(s); while(!q.empty()){ int u = q.front(); q.pop(); for(auto V : g[u]){ if(V.w &gt; 0 and dis[V.v] &gt; dis[u] + 1){ dis[V.v] = dis[u] + 1; q.push(V.v); } } } if(dis[t] == inf) return 0; return 1; } int cur[MAX]; int aug(int u, int now, int t){ if(u == t) return now; int ans = 0; for(int &amp;i = cur[u]; i &lt; g[u].size(); i++){ int v = g[u][i].v, w = g[u][i].w, cp = g[u][i].cp; if(dis[v] != dis[u] + 1) continue; int ret = aug(v, min(w, now), t); g[u][i].w -= ret, g[v][cp].w += ret; now -= ret, ans += ret; if(now &lt;= 0) break; } return ans; } void add_edge(int u, int v, int w){ g[u].pb(node{v, w, g[v].size()}); g[v].pb(node{u, 0, g[u].size() - 1}); } }; flow g; int id[MAX]; int a[MAX]; void solve(){ int n = read(); for(int i = 1; i &lt;= n; i++){ a[i] = read(); } psz = 2; int s = 1, t = 2; for(int i = 1; i &lt;= 60; i++){ id[i] = ++psz; g.add_edge(id[i], t, 1); } for(int i = 1; i &lt;= n; i++){ int now = ++psz; g.add_edge(s, now, 1); for(int j = 1; j &lt;= 60; j++){ if(a[i] &amp; (1ll &lt;&lt; (j - 1))){ g.add_edge(now, id[j], inf); } } } int ans = 0; while(g.bfs(s, t)){ for(int i = 1; i &lt;= psz; i++) g.cur[i] = 0; ans += g.aug(s, inf, t); } write(n - ans), endl; for(int i = 1; i &lt;= psz; i++) g.g[i].clear(); } signed main(){ int t = read(); while(t--) solve(); return 0; } CF1815D XOR Counting *2600 有点虚高。 n,mn,mn,m 大的吓人，而且 mmm 居然不是 ∑m≤105\\sum m\\leq 10^5∑m≤105 于是果断打表。发现 m&gt;3m&gt;3m&gt;3 的情况都一样，而且明显可以 O(1)O(1)O(1) 算出。只剩下 m=2m=2m=2 的情况了。 这部分不太容易。发现如果 nnn 为奇数那么最后一位一定为 1。启发了一个分治的算法。设 fi,gif_i,g_ifi​,gi​ 表示 n=in=in=i 时候的答案和值的方案数。那么转移有： fi=2fi−12+gi−12,i∤2f_i = 2f_{i-1\\over 2} + g_{i-1\\over 2}, i \\nmid 2 fi​=2f2i−1​​+g2i−1​​,i∤2 fi=2fi2+2fi2−1,i∣2f_i = 2f_{i\\over 2} + 2f_{i\\over 2-1}, i \\mid 2 fi​=2f2i​​+2f2−1i​​,i∣2 点击查看代码 // Problem: XOR Counting // URL: https://www.luogu.com.cn/problem/CF1815D // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int mod = 998244353; int quickPower(int a,int b,int p){int base=a,ans=1;while(b){if(b&amp;1)ans*=base,ans%=p;base*=base;base%=p;b&gt;&gt;=1;}return ans;} map &lt;int,int&gt; f, g; void dfs(int x){ if(f.count(x)) return ; if(x % 2){ dfs(x / 2); f[x] = (2 * f[x / 2] % mod + g[x / 2]) % mod, g[x] = g[x / 2]; }else{ dfs(x / 2);dfs(x / 2 - 1); f[x] = 2 * (f[x / 2] + f[x / 2 - 1]) % mod; g[x] = (g[x / 2] + g[x / 2 - 1]) % mod; } } void solve(){ int n = read(), m = read(); f[0] = 0, g[0] = 1; if(m == 1){ write(n % mod), endl; }else if(m &gt; 2){ if(n % 2){ write((1 + n) % mod * ((n + 1) % mod) % mod * quickPower(4, mod - 2, mod) % mod), endl; } else{ write((1 + n / 2 % mod) % mod * (n / 2 % mod) % mod), endl; } }else{ dfs(n); write(f[n]), endl; } } signed main(){ int t = read(); while(t--) solve(); return 0; } CF212D Cutting a Fence *2500 考虑一个数的贡献。然后差分就过了。 点击查看代码 // Problem: Cutting a Fence // URL: https://www.luogu.com.cn/problem/CF212D // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 1e6 + 10; int a[MAX]; int L[MAX], R[MAX]; int s[MAX], s2[MAX]; void solve(){ int n = read(); for(int i = 1; i &lt;= n; i++){ a[i] = read(); } stack &lt;pair &lt;int, int&gt; &gt; stc; stc.push(make_pair(-1, 0)); for(int i = 1; i &lt;= n; i++){ while(stc.top().first &gt; a[i]) stc.pop(); L[i] = stc.top().second; stc.push(make_pair(a[i], i)); } while(!stc.empty()) stc.pop(); stc.push(make_pair(-1, n + 1)); for(int i = n; i &gt;= 1; i--){ while(stc.top().first &gt;= a[i]) stc.pop(); R[i] = stc.top().second; stc.push(make_pair(a[i], i)); } for(int i = 1; i &lt;= n; i++){ int len = R[i] - L[i] - 1; int add = min(i - L[i], R[i] - i); // write(i), put(), write(len), put(), write(add), endl; s2[1] += a[i], s2[1 + add] -= a[i]; s2[len + 2] += a[i], s2[len + 2 - add] -= a[i]; } int now = 0; for(int i = 1; i &lt;= n; i++){ now += s2[i]; s2[i] = now; } now = 0; for(int i = 1; i &lt;= n; i++){ now += s2[i]; s2[i] = now; } int q = read(); while(q--){ int i = read(); printf(&quot;%.9lf\\n&quot;, double(s2[i]) / double(n - i + 1)); } } signed main(){ int t = 1; while(t--) solve(); return 0; } CF1889C2 Doremy's Drying Plan (Hard Version) *2600 设 fi,jf_{i,j}fi,j​ 表示前 iii 个点钦定点 iii 不被覆盖最大答案。则有 fi,j=max⁡fk,j−cst+1f_{i,j} = \\max f_{k,j-cst} + 1fi,j​=maxfk,j−cst​+1 其中 cstcstcst 为包含 iii 但不包含 kkk 的方案数。考虑优化，发现 cst≤kcst \\leq kcst≤k 所以最多只有 k+1k+1k+1 段转移。使用 st 表以做到 nk2nk^2nk2。代码实在是不想写了，破防了。 CF1685C Bring Balance *2600 感受出来了。首先直觉告诉我们答案上界非常少。不难发现上界为 2。具体的，设 iii 为前缀和最大的点，那么反转 [1,i],[i+1,2n][1,i],[i+1,2n][1,i],[i+1,2n] 一定可行。只需要看怎么得到答案为 1 的。发现反转序列一定要包含最左边的小于 0 的和最右边小于 0 的。那么贪心的选左边最大的和右边最大的反转看看行不行。 点击查看代码 // Problem: Bring Balance // URL: https://www.luogu.com.cn/problem/CF1685C // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 1e6 + 10; char a[MAX]; int s[MAX]; void solve(){ int n = read(); bool fl = 0; for(int i = 1; i &lt;= 2 * n; i++){ a[i] = getchar(); while(a[i] != '(' and a[i] != ')') a[i] = getchar(); s[i] = s[i - 1] + ((a[i] == '(') ? 1 : -1); fl |= (s[i] &lt; 0); } if(!fl) { puts(&quot;0&quot;); return ; } int l = -1, r = -1; for(int i = 1; i &lt;= 2 * n; i++){ if(s[i] &lt; 0){ if(l == -1) l = i; r = i; } } int rl = 0; for(int i = 1; i &lt;= l; i++) if(s[i] &gt; s[rl]) rl = i; int rr = 2 * n; for(int i = 2 * n; i &gt;= r; i--) if(s[i] &gt; s[rr]) rr = i; l = rl + 1, r = rr; int mk = 0; for(int i = 1; i &lt;= 2 * n; i++) if(s[i] &gt;= s[mk]) mk = i; for(int i = 1; i &lt;= (r - l + 1) / 2; i++){ swap(a[l + i - 1], a[r - i + 1]); } fl = 0; for(int i = 1; i &lt;= 2 * n; i++){ s[i] = s[i - 1] + ((a[i] == '(') ? 1 : -1); fl |= (s[i] &lt; 0); } if(!fl){ puts(&quot;1&quot;); write(l), put(), write(r), endl; return ; } puts(&quot;2&quot;); write(1), put(), write(mk), endl; write(mk + 1), put(),write(2 * n), endl; } signed main(){ int t = read(); while(t--) solve(); return 0; } CF1893D Colorful Constructive *2600 感觉对上脑电波的难度有点高。考虑把每个架子划分成若干个长度为 cic_ici​ 的架子。每个新架子要求所有元素不同。不难发现这和合法方案形成了双射。然后你就贪心的填就好了。 点击查看代码 // Problem: Colorful Constructive // URL: https://www.luogu.com.cn/problem/CF1893D // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 5e5 + 10; int a[MAX], b[MAX], c[MAX]; vector &lt;int&gt; ans[MAX]; int cnt[MAX]; int vis[MAX]; void solve(){ int n = read(), m = read(); for(int i = 1; i &lt;= n; i++){ a[i] = read(); cnt[i] = 0; } for(int i = 1; i &lt;= n; i++){ cnt[a[i]]++; } for(int i = 1; i &lt;= m; i++){ b[i] = read(); ans[i].clear(); } vector &lt;pair&lt;int,int&gt;&gt; A; for(int i = 1; i &lt;= m; i++){ c[i] = read(); for(int j = 1; j &lt;= b[i] / c[i]; j++) A.pb(make_pair(c[i], i)); if(b[i] % c[i]) A.pb(make_pair(b[i] % c[i], i)); } sort(A.begin(), A.end()); priority_queue &lt;pair&lt;int,int&gt;&gt; que; for(int i = 1; i &lt;= n; i++){ if(cnt[i]) que.push(make_pair(cnt[i], i)); } for(int i = A.size() - 1; i &gt;= 0; i--){ vector &lt;pair&lt;int,int&gt;&gt; got; int len = A[i].first; for(int j = 1; j &lt;= len; j++){ if(que.empty()){ puts(&quot;-1&quot;); return ; } auto u = que.top(); que.pop(); u.first--; ans[A[i].second].pb(u.second); if(u.first) got.pb(u); } for(auto u : got) que.push(u); } for(int T = 1; T &lt;= m; T++){ reverse(ans[T].begin(), ans[T].end()); for(int i = 0; i &lt; b[T] % c[T]; i++) vis[ans[T][i]] = i + 1, write(ans[T][i]), put(); for(int i = b[T] % c[T]; i &lt; b[T]; i += c[T]){ priority_queue &lt;pair&lt;int,int&gt;&gt; que; for(int j = i; j &lt;= i + c[T] - 1; j++){ if(vis[ans[T][j]]) que.push(make_pair(-vis[ans[T][j]], ans[T][j])); else que.push(make_pair(1, ans[T][j])); } for(int j = i - 1; j &gt;= max(0ll, i - 1 - c[T] + 1); j--){ vis[ans[T][j]] = 0; } for(int j = i; j &lt;= i + c[T] - 1; j++){ vis[que.top().second] = j + 1; write(que.top().second), put(); que.pop(); } } for(int j = b[T] - 1; j &gt;= max(0ll, b[T] - 1 - c[T] + 1); j--) vis[ans[T][j]] = 0; endl; } } //20 18 12 11 8 15 12 8 20 17 signed main(){ int t = read(); while(t--) solve(); return 0; } CF677D Vanya and Treasure *2300 直接考虑 i,i+1i,i+1i,i+1 的贡献然后拆绝对值扫描线。 点击查看代码 #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 705; int a[MAX][MAX]; int dis[MAX][MAX]; vector &lt; pair&lt;int,int&gt;&gt; col[MAX * MAX]; struct Seg{ int s[MAX &lt;&lt; 2], tag[MAX &lt;&lt; 2], tag2[MAX &lt;&lt; 2]; void pushup(int x){ s[x] = min(s[x &lt;&lt; 1], s[x &lt;&lt; 1 | 1]); } void pushdown(int x, int l, int r){ if(tag2[x]){ s[x &lt;&lt; 1] = s[x &lt;&lt; 1 | 1] = inf; tag[x &lt;&lt; 1] = tag[x &lt;&lt; 1 | 1] = 0; tag2[x &lt;&lt; 1] = tag2[x &lt;&lt; 1 | 1] = 1; tag2[x] = 0; } if(tag[x]){ s[x &lt;&lt; 1] += tag[x], s[x &lt;&lt; 1 | 1] += tag[x]; tag[x &lt;&lt; 1] += tag[x], tag[x &lt;&lt; 1 | 1] += tag[x]; tag[x] = 0; } } void upd(int l, int r, int pos, int val, int x){ if(l == r){ s[x] = val; tag[x] = tag2[x] = 0; return ; } int mid = (l + r) &gt;&gt; 1; pushdown(x, l, r); if(pos &lt;= mid) upd(l, mid, pos, val, x &lt;&lt; 1); else upd(mid + 1, r, pos, val, x &lt;&lt; 1 | 1); pushup(x); } void add(int val){ pushdown(1, 1, 1); s[1] += val; tag[1] += val; } void clear(){ s[1] = inf, tag[1] = 0; tag2[1] = 1; } int query(int l, int r, int dl, int dr, int x){ if(dl &lt;= l and r &lt;= dr) return s[x]; int mid = (l + r) &gt;&gt; 1, ans = inf; pushdown(x, l, r); if(dl &lt;= mid) ans = min(ans, query(l, mid, dl, dr, x &lt;&lt; 1)); if(dr &gt; mid) ans = min(ans, query(mid + 1, r, dl, dr, x &lt;&lt; 1 | 1)); pushup(x); return ans; } }; Seg seg1, seg2; void solve(){ int n = read(), m = read(), p = read(); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) a[i][j] = read(); for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++) dis[i][j] = inf; } for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) col[a[i][j]].pb(make_pair(i, j)); for(int i = 1; i &lt;= p; i++){ sort(col[i].begin(), col[i].end()); } for(auto u : col[1]){ dis[u.first][u.second] = u.first - 1 + u.second - 1; } for(int i = 2; i &lt;= p; i++){ int l = 0, r = 0; seg1.clear(), seg2.clear(); int lst = 0; while(r &lt; col[i].size()){ if(l == col[i - 1].size()){ auto u = col[i][r]; seg1.add(u.first - lst); seg2.add(u.first - lst); lst = u.first; int ans = inf; ans = min(ans, seg1.query(1, m, 1, u.second, 1) + u.second); ans = min(ans, seg2.query(1, m, u.second, m, 1) - u.second); dis[u.first][u.second] = ans; r++; }else{ auto u = col[i][r], v = col[i - 1][l]; if(u &lt; v){ seg1.add(u.first - lst); seg2.add(u.first - lst); lst = u.first; int ans = inf; ans = min(ans, seg1.query(1, m, 1, u.second, 1) + u.second); ans = min(ans, seg2.query(1, m, u.second, m, 1) - u.second); dis[u.first][u.second] = ans; r++; }else{ u = v; seg1.add(u.first - lst); seg2.add(u.first - lst); lst = u.first; seg1.upd(1, m, u.second, dis[u.first][u.second] - u.second, 1); seg2.upd(1, m, u.second, dis[u.first][u.second] + u.second, 1); l++; } } } r = col[i].size() - 1, l = col[i - 1].size() - 1; lst = n + 1; seg1.clear(), seg2.clear(); while(r &gt;= 0){ if(l &lt; 0){ auto u = col[i][r]; seg1.add(lst - u.first); seg2.add(lst - u.first); lst = u.first; int ans = inf; ans = min(ans, seg1.query(1, m, 1, u.second, 1) + u.second); ans = min(ans, seg2.query(1, m, u.second, m, 1) - u.second); dis[u.first][u.second] = min(dis[u.first][u.second], ans); r--; }else{ auto u = col[i][r], v = col[i - 1][l]; if(u &gt; v){ auto u = col[i][r]; seg1.add(lst - u.first); seg2.add(lst - u.first); lst = u.first; int ans = inf; ans = min(ans, seg1.query(1, m, 1, u.second, 1) + u.second); ans = min(ans, seg2.query(1, m, u.second, m, 1) - u.second); dis[u.first][u.second] = min(dis[u.first][u.second], ans); r--; }else{ u = v; seg1.add(lst - u.first); seg2.add(lst - u.first); lst = u.first; seg1.upd(1, m, u.second, dis[u.first][u.second] - u.second, 1); seg2.upd(1, m, u.second, dis[u.first][u.second] + u.second, 1); l--; } } } } int ans = inf; for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= m; j++) { if(a[i][j] == p) ans = min(ans, dis[i][j]); } } write(ans), endl; } signed main(){ int t = 1; while(t--) solve(); return 0; } CF2038G Guess One Character *1900 但是大聪明题。 首先问一次 1，如果 1 的个数是 0 或者 nnn 那么我们可以直接断定这个字符串是全 0/1 的。 否则再问一次 11 的个数。用 1 的个数减去 11 的个数即可得到 1 连续段的个数。这很有用。我们再问 01 出现的次数。不难发现，一个以 0 开头的字符串 01 和 1 的连续段个数相等。以 1 开头的字符串 01 比 1 的连续段个数少一。至此我们可以猜出字符串开头的那个是什么。 点击查看代码 // Problem: G. Guess One Character // URL: https://codeforces.com/contest/2038/problem/G // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back void solve(){ int n; cin &gt;&gt; n; cout &lt;&lt; &quot;1 1&quot; &lt;&lt; endl; int a; cin &gt;&gt; a; if(a == n){ cout &lt;&lt; &quot;0 1 1&quot; &lt;&lt; endl; int ans; cin &gt;&gt; ans; return ; } if(a == 0){ cout &lt;&lt; &quot;0 1 0&quot; &lt;&lt; endl; int ans; cin &gt;&gt; ans; return ; } cout &lt;&lt; &quot;1 11&quot; &lt;&lt; endl; int b; cin &gt;&gt; b; int c = a - b; cout &lt;&lt; &quot;1 01&quot; &lt;&lt; endl; int d; cin &gt;&gt; d; if(d == c){ cout &lt;&lt; &quot;0 1 0&quot; &lt;&lt; endl; int ans; cin &gt;&gt; ans; return ; } cout &lt;&lt; &quot;0 1 1&quot; &lt;&lt; endl; int ans; cin &gt;&gt; ans; return ; } signed main(){ int t = 1; cin &gt;&gt; t; while(t--) solve(); return 0; } CF1975F Set *2600 神题。题解后面补。 点击查看代码 // Problem: Set // URL: https://www.luogu.com.cn/problem/CF1975F // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 21; int n; int f[MAX][(1ll &lt;&lt; MAX)]; vector &lt;int&gt; ans; void dfs(int s, int x){ if(x == n){ if(f[x][0] % 2) ans.pb(s); return ; } for(int i = 0; i &lt; (1ll &lt;&lt; (n - x - 1)); i++) f[x + 1][i] = f[x][i] &amp; f[x][i | (1ll &lt;&lt; (n - x - 1))]; dfs(s &lt;&lt; 1, x + 1); for(int i = 0; i &lt; (1ll &lt;&lt; (n - x - 1)); i++) f[x + 1][i] = f[x][i] &amp; (f[x][i | (1ll &lt;&lt; (n - x - 1))] &gt;&gt; 1); dfs(s &lt;&lt; 1 | 1, x + 1); } void solve(){ n = read(); f[0][0] = 1; for(int i = 1; i &lt; (1ll &lt;&lt; n); i++){ f[0][i] = read(); } dfs(0, 0); write(ans.size()), endl; for(int u : ans) write(u), endl; } signed main(){ int t = 1; while(t--) solve(); return 0; } CF1592F1/2 Alice and Recoloring 2 分别是 *2600/*2800。 首先不难发现费用为 1 这个操作很牛逼。直接让选左下和右上的操作🤡了，压根没用。所以只考虑操作右下和左上角。然后是套路地转化（tm又没想到）为差分数组来考虑。时光倒流。不妨令 ai,j=(ci+1,j+ci,j+1−ci+1,j+1)mod 2a_{i,j} = (c_{i+1,j} + c_{i,j+1} - c_{i + 1,j+1}) \\mod 2ai,j​=(ci+1,j​+ci,j+1​−ci+1,j+1​)mod2。那么全 aaa 全 0 当且仅当 ccc 也全 0。然后就转化为选左上的是单点修改，选右下的是修改 ci,j,cn,j,ci,m,cn,mc_{i,j}, c_{n,j}, c_{i,m}, c_{n,m}ci,j​,cn,j​,ci,m​,cn,m​. F1 代价为 3。那么只比直接进行操作 1 优秀 1 的代价。所以我们最多进行 1 次右下使得 cn,m=0c_{n,m} = 0cn,m​=0 然后就不优了。直接判断存不存在 ci,j,=cn,j=ci,m=cn,m=1c_{i,j},=c_{n,j}= c_{i,m}= c_{n,m}=1ci,j​,=cn,j​=ci,m​=cn,m​=1 即可。这时 ans=∑ci,j−1ans = \\sum c_{i,j} - 1ans=∑ci,j​−1 反之则为 ∑ci,j\\sum c_{i,j}∑ci,j​。 点击查看代码 // Problem: Alice and Recoloring 2 // URL: https://www.luogu.com.cn/problem/CF1592F2 // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 505 + 10; char a[MAX][MAX]; int b[MAX][MAX]; int c[MAX][MAX]; void solve(){ int n = read(), m = read(); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) do{a[i][j] = getchar();}while(a[i][j] != 'W' and a[i][j] != 'B'); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) if(a[i][j] == 'B') b[i][j] = 1; int ans = 0; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) c[i][j] = (b[i][j] + b[i + 1][j] + b[i][j + 1] + b[i + 1][j + 1]) % 2, ans += c[i][j]; for(int i = 1; i &lt; n; i++) for(int j = 1; j &lt; m; j++) if(c[i][j] and c[i][m] and c[n][j] and c[n][m]) write(ans - 1), endl, exit(0); write(ans), endl; return ; } signed main(){ int t = 1; while(t--) solve(); return 0; } F2 代价为 2 那么优秀了 2 代价。意味着可以忽略 cn,mc_{n,m}cn,m​ 只在 ci,j=cn,j=ci,m=1c_{i,j} = c_{n,j} = c_{i,m} = 1ci,j​=cn,j​=ci,m​=1 的时候操作就更优！不难注意到这相当于一行一列只能操作一次。不难发现这是一个二分图最大匹配。可以做到你想做到的复杂度。 点击查看代码 // Problem: Alice and Recoloring 2 // URL: https://www.luogu.com.cn/problem/CF1592F2 // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 1e3 + 10; int psz = 2; struct flow{ struct node{ int v, w, cp; }; vector &lt;node&gt; g[MAX ]; int dis[MAX]; bool bfs(int s, int t){ for(int i = 1; i &lt;= psz; i++) dis[i] = mininf; dis[s] = 0; queue &lt;int&gt; q; q.push(s); while(!q.empty()){ int u = q.front(); q.pop(); for(auto V : g[u]){ if(V.w &gt; 0 and dis[V.v] &gt; dis[u] + 1){ dis[V.v] = dis[u] + 1; q.push(V.v); } } } if(dis[t] == mininf) return 0; return 1; } int cur[MAX]; int aug(int u, int now, int t){ if(u == t) return now; int ans = 0; for(int &amp;i = cur[u]; i &lt; g[u].size(); i++){ int v = g[u][i].v, w = g[u][i].w, cp = g[u][i].cp; if(dis[v] != dis[u] + 1) continue; int ret = aug(v, min(w, now), t); g[u][i].w -= ret, g[v][cp].w += ret; now -= ret, ans += ret; if(now &lt;= 0) break; } return ans; } void add_edge(int u, int v, int w){ g[u].pb(node{v, w, g[v].size()}); g[v].pb(node{u, 0, g[u].size() - 1}); } }; flow G; int id[MAX], id2[MAX]; char a[MAX][MAX]; int b[MAX][MAX]; int c[MAX][MAX]; void solve(){ int n = read(), m = read(); int s = 1, t = 2; for(int i = 1; i &lt; n; i++) id[i] = ++psz; for(int i = 1; i &lt; m; i++) id2[i] = ++psz; for(int i = 1; i &lt; n; i++) G.add_edge(s, id[i], 1); for(int i = 1; i &lt; m; i++) G.add_edge(id2[i], t, 1); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) do{a[i][j] = getchar();}while(a[i][j] != 'W' and a[i][j] != 'B'); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) if(a[i][j] == 'B') b[i][j] = 1; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) c[i][j] = (b[i][j] + b[i + 1][j] + b[i][j + 1] + b[i + 1][j + 1]) % 2; for(int i = 1; i &lt; n; i++) for(int j = 1; j &lt; m; j++) if(c[i][j] and c[n][j] and c[i][m]) G.add_edge(id[i], id2[j], 1); int ans = 0; while(G.bfs(s, t)){for(int i = 1; i &lt;= psz; i++){G.cur[i] = 0;}ans -= G.aug(s, inf, t);} c[n][m] ^= (-ans % 2); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) ans += c[i][j]; write(ans), endl; return ; } signed main(){ int t = 1; while(t--) solve(); return 0; } CF1572C Paint *2700 时光倒流答案加一转为 P4170 [CQOI2007] 涂色。题目条件非常特殊。打表观测转移点非常可疑，猜测一定是和开头颜色相同或者与结尾颜色相同的才优秀。过了。。。。。 点击查看代码 // Problem: Paint // URL: https://www.luogu.com.cn/problem/CF1572C // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 3003; const int inf = 1e18; int f[MAX][MAX]; int a[MAX]; int cnt[MAX]; int nxt[MAX], lst[MAX]; void solve(){ int n = read(); for(int i = 1; i &lt;= n; i++){ a[i] = read(); cnt[i] = 0; } for(int i = 1; i &lt;= n; i++){ lst[i] = cnt[a[i]]; cnt[a[i]] = i; } for(int i = 1; i &lt;= n; i++) cnt[i] = n + 1; for(int i = n; i &gt;= 1; i--){ nxt[i] = cnt[a[i]]; cnt[a[i]] = i; } for(int i = 1; i &lt;= n; i++) for(int j = i; j &lt;= n; j++) f[i][j] = inf; for(int i = 1; i &lt;= n; i++){ f[i][i] = 1; } for(int len = 2; len &lt;= n; len++){ for(int i = 1; i + len - 1 &lt;= n; i++){ int j = i + len - 1; if(a[i] == a[j]){ f[i][j] = min(f[i+1][j], f[i][j-1]); }else{ for(int k = i; k &lt;= j; k = nxt[k]){ f[i][j] = min(f[i][j], f[i][k] + f[k+1][j]); } for(int k = j; k &gt;= i; k = lst[k]){ f[i][j] = min(f[i][j], f[i][k] + f[k+1][j]); } } } } write(f[1][n] - 1), endl; } signed main(){ int t = read(); while(t--) solve(); return 0; } CF1572D Bridge Club 考研直觉的题目。可惜我没有。 首先这肯定是只能二分图最大匹配了。关键在于如何优化？ 所以肯定是只能优化建图了。考虑保留最大的一些边，使得一定能找出一组大小为 kkk 的匹配即可。 点击查看代码 // Problem: Bridge Club // URL: https://www.luogu.com.cn/problem/CF1572D // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX2 = 12e5 + 10; const int MAX = 4e4 + 10; int psz = 2; struct min_max_flow{ int cur[MAX], dis[MAX]; int vis[MAX]; struct Edge{ int v, w, c, cp; }; vector &lt;Edge&gt; g[MAX]; void add_edge(int u, int v, int w, int c){ Edge e1 = Edge{v, w, c, g[v].size()}; Edge e2 = Edge{u, 0, -c, g[u].size()}; g[u].push_back(e1); g[v].push_back(e2); } bool bfs(int s, int t) { queue&lt;int&gt; q; for(int i = 0; i &lt;= psz; i++){ dis[i] = inf; } memset(vis, 0, sizeof(vis)); vis[s] = true; dis[s] = 0; q.push(s); while(!q.empty()){ int u = q.front(); q.pop(); vis[u] = false; int l = g[u].size(); for(int i = 0; i &lt; l; i++) { int v = g[u][i].v, r = g[u][i].w, c = g[u][i].c; if(r and dis[u] + c &lt; dis[v]){ dis[v] = dis[u] + c; if(!vis[v]){ vis[v] = true; q.push(v); } } } } return dis[t] != inf; } int aug(int u, int l, int &amp;cost, int t){ if(u == t) return l; vis[u] = true; int f = 0; for(int &amp;i = cur[u]; i &lt; g[u].size(); i++){ int v = g[u][i].v, r = g[u][i].w, c = g[u][i].c; if(dis[v] != dis[u] + c or !r or vis[v]) continue; int d = aug(v, min(r, l), cost, t); g[u][i].w -= d; g[v][g[u][i].cp].w += d; f += d, l -= d; cost += d*c; if(!l) break; } vis[u] = false; return f; } }; min_max_flow G; unsigned id[MAX2]; unsigned a[MAX2]; void solve(){ int n = read(), k = read(); int s = 1, t = 2; int t3 = ++psz; for(int i = 0; i &lt; (1ll &lt;&lt; n); i++){ a[i] = read(); } priority_queue &lt; pair&lt;signed, pair&lt;signed,signed&gt;&gt; &gt; que; for(int i = 0; i &lt; (1ll &lt;&lt; n); i++){ if(__builtin_popcount(i) % 2) continue; for(int j = 0; j &lt; n; j++){ int u = i, v = (i ^ (1ll &lt;&lt; j)); que.push(make_pair(a[i] + a[i ^ (1ll &lt;&lt; j)], make_pair(u, v))); } } for(int i = 1; i &lt;= k * (2 * n - 1); i++){ if(que.empty()) break; auto u = que.top(); que.pop(); if(!id[u.second.first]) id[u.second.first] = ++psz; if(!id[u.second.second]) id[u.second.second] = ++psz; int l = id[u.second.first], r = id[u.second.second]; G.add_edge(l, r, 1, (long long)(-u.first)); } for(int i = 0; i &lt; (1ll &lt;&lt; n); i++){ if(id[i]){ if(__builtin_popcount(i) % 2){ G.add_edge(id[i], t3, 1, 0); }else{ G.add_edge(s, id[i], 1, 0); } } } G.add_edge(t3, t, k, 0); int ans = 0, cost = 0; while(G.bfs(s, t)){ for(int i = 1; i &lt;= psz; i++) G.cur[i] = 0; ans += G.aug(s, inf, cost, t); } write(-cost), endl; } signed main(){ int t = 1; while(t--) solve(); return 0; } CF1103C Johnny Solving *2700 古老简单套路题。 套路地，拎出这个图的一颗生成树，如果这颗生成树的直径 ≥nk\\geq {n \\over k}≥kn​ 那么就直接做完了。否则让我们来研究一下这棵树的性质。由于保证所以节点度数大于等于三所以我们考虑去研究度数为一的叶子结点的性质。直觉上，树高小，叶子节点个数比较多。不妨设有 xxx 个叶子节点，那么基于这棵树直径则 nkx&gt;n{n\\over k}x &gt; nkn​x&gt;n 所以 x&gt;kx &gt; kx&gt;k 这也就意味着我们只需要在这些个叶子上面找环。叶子节点两个祖先，怎么找都能找到。 点击查看代码 // Problem: Johnny Solving // URL: https://www.luogu.com.cn/problem/CF1103C // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 3e5 + 10; vector &lt;int&gt; g[MAX]; vector &lt;int&gt; g2[MAX]; int dep[MAX]; int dis[MAX], pre[MAX]; int Fa[MAX]; vector &lt;int&gt; lf; void dfs(int u, int fa){ dep[u] = dep[fa] + 1; Fa[u] = fa; int cnt = 0; for(int v : g[u]){ if(v == fa) continue; if(dep[v]) continue; cnt++; dfs(v, u); g2[u].pb(v), g2[v].pb(u); } if(!cnt){ lf.pb(u); } } void dfs2(int u, int fa){ dis[u] = dis[fa] + 1; pre[u] = fa; int cnt = 0; for(int v : g2[u]){ if(v == fa) continue; dfs2(v, u); } } void solve(){ int n = read(), m = read(), k = read(); for(int i = 1; i &lt;= m; i++){ int u = read(), v = read(); g[u].pb(v), g[v].pb(u); } dfs(1, 1); int mk = 0; for(int i = 1; i &lt;= n; i++) if(dep[i] &gt; dep[mk]) mk = i; dfs2(mk, mk); int mk2 = 0; for(int i = 1; i &lt;= n; i++) if(dis[i] &gt; dis[mk2]) mk2 = i; // write(mk2), put(), write(mk), endl; if(dis[mk2] &gt;= (n + k - 1) / k){ puts(&quot;PATH&quot;); vector &lt;int&gt; ans; while(mk2 != mk){ ans.pb(mk2); mk2 = pre[mk2]; } ans.pb(mk); write(ans.size()), endl; for(int u : ans) write(u), put(); endl; return ; } puts(&quot;CYCLES&quot;); int cnt = 0; for(int u : lf){ bool fl = 0; for(int v : g[u]){ if(v == Fa[u]){ continue; } if((dep[u] - dep[v] + 1) % 3){ fl = 1; write(dep[u] - dep[v] + 1), endl; int now = u; while(now != v){ write(now), put(); now = Fa[now]; } write(v), endl; break; } } if(fl){ cnt++; if(cnt == k) break; continue; } for(int v : g[u]){ if(v == Fa[u]) continue; for(int v2 : g[u]){ if(v2 == Fa[u] or v2 == v) continue; if(dep[v] &lt; dep[v2]) swap(v,v2); write(dep[v] - dep[v2] + 2), endl; while(v != v2){ write(v), put(); v = Fa[v]; } write(v), put(), write(u), endl; break; } break; } cnt++; if(cnt == k) break; } } signed main(){ int t = 1; while(t--) solve(); return 0; } CF607C Marbles *2500 duel 题，对面貌似是 SS 教练，恐怖。 但是这题真的有够垃圾的。首先结尾要是相反那包不行的。其他的情况手玩了一下，感受了一下，貌似也只有末尾是回文相等的不行。交了一发发现过了。 点击查看代码 // Problem: Marbles // URL: https://www.luogu.com.cn/problem/CF607C // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 1e6 + 10; const int mod = 998244353; int a[MAX], b[MAX]; int pre[MAX]; int hsh[10]; int hsh2[10]; int base[10]; int base2[10]; void solve(){ int n = read(); for(int i = 1; i &lt; n; i++){ char ch = getchar(); while(ch != 'N' and ch != 'S' and ch != 'E' and ch != 'W') ch = getchar(); if(ch == 'E') a[i] = 0; else if(ch == 'S') a[i] = 1; else if(ch == 'N') a[i] = 2; else a[i] = 3; } for(int i = 1; i &lt; n; i++){ char ch = getchar(); while(ch != 'N' and ch != 'S' and ch != 'E' and ch != 'W') ch = getchar(); if(ch == 'E') b[i] = 0; else if(ch == 'S') b[i] = 1; else if(ch == 'N') b[i] = 2; else b[i] = 3; } for(int i = 1; i &lt; n; i++){ b[i] = 3 - b[i]; } mt19937 Rnd(time(0)); for(int i = 0; i &lt; 10; i++){ base[i] = Rnd(); } base[0] = 131, base[2] = 13331; for(int i = 0; i &lt; 10; i++){ base2[i] = 1; } for(int i = n - 1; i &gt;= 1; i--){ for(int j = 0; j &lt; 10; j++) hsh[j] = (hsh[j] * base[j] + a[i]) % mod; for(int j = 0; j &lt; 10; j++){ hsh2[j] = (hsh2[j] + b[i] * base2[j]) % mod; base2[j] = base2[j] * base[j] % mod; } bool ans = 1; for(int j = 0; j &lt; 10; j++) ans = (ans &amp; (hsh[j] == hsh2[j])); if(ans) puts(&quot;NO&quot;), exit(0); } puts(&quot;YES&quot;); } signed main(){ int t = 1; while(t--) solve(); return 0; } NOIp2024 Rp++.所以上面这道题可能是我还在认真学的时候最后一题了，哈哈。 ","tags":[],"title":"In Rainbows","feature":"https://WRuperD.github.io/post-images/in-rainbows.jpeg","link":"https://WRuperD.github.io/post/in-rainbows/","stats":{"text":"52 min read","time":3078000,"words":8860,"minutes":52},"date":"2024-11-12 21:38:35","dateFormat":"2024-11-12"},{"abstract":"","content":"题解 P10743 [SEERC2020] AND = OR 提供一种好写的 O(nlog⁡nlog⁡V)O(n \\log n \\log V)O(nlognlogV) 的做法。 先考虑如何对于给定的 l,rl,rl,r 在 O(nlog⁡n)O(n\\log n)O(nlogn) 的复杂度单次求解。不难发现，我们每一次一定是取值域上连续的一段前缀的 OR⁡\\operatorname{OR}OR 和连续的一段后缀的 AND⁡\\operatorname{AND}AND。排序之后就行了。 类似于 P8421 的做法，不难注意到前缀 OR⁡\\operatorname{OR}OR 和后缀 AND⁡\\operatorname{AND}AND 的变化量是 log⁡V\\log VlogV 的。所以我们只需要拎出那些有用的值即可。具体的，我们可以考虑使用 log⁡V\\log VlogV 个 ststst 表维护区间最大的二进制下第 iii 位为 0 的数值和它的位置/区间最小的二进制下第 iii 位为 1 的数值和它的位置。不难发现对于一个值它最多只会有两个被加入可能有贡献的数组。所以可能有贡献的数就还是 log⁡V\\log VlogV 级别的。通过预处理可以知道区间内是否有 ≥2\\geq 2≥2 个那个值。 最后我们直接对着可能的值做暴力。 总的复杂度就是 O(nlog⁡nlog⁡V+qlog⁡Vlog⁡V)O(n \\log n \\log V + q \\log V \\log V)O(nlognlogV+qlogVlogV)。实践证明瓶颈在前半部分。 至此我们在原数据范围下通过。 ","tags":[],"title":"2024-11-08-solution-p10743","feature":"","link":"https://WRuperD.github.io/post/2024-11-08-solution-p10743/","stats":{"text":"2 min read","time":87000,"words":361,"minutes":2},"date":"2024-11-08 18:53:36","dateFormat":"2024-11-08"},{"abstract":"","content":"巨大简单题。看完样例就会做了吧。 首先考虑如果权值最大的边和权值次大的边的和大于 ddd 那么一定无解。（原因是树是联通的所以直径一定至少是这个值。） 不妨设最大权值为 www，次大的为 w′w&#x27;w′。 所以我们不妨直接把他们挂在一个节点上。考虑如果我们钦定这个直径包括了边权最大的那条边的话，那么就相当于我们还有在这个节点上面挂一条长度为 d−wd-wd−w 的链。只要能凑出来就一定行。原因：我们把除了这条链上的边全部也挂在这个节点上，那么首先有 d−w≥w′d-w \\geq w&#x27;d−w≥w′ 所以我们一定是会取这条链和最大权值边作为我们的直径的。接着考虑权值最大的边不作为直径上的边。那么我们就必须要挂两条权值和大于 www 的链。同理在这种情况下我们也会直接选择这两条链。所以我们直接对这两部跑动态规划解决就可以了。使用 bitset 以做到 O(d3ω)O({d^3\\over \\omega})O(ωd3​)。 // Problem: Construct Tree // URL: https://www.luogu.com.cn/problem/CF1917F // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 2e3 + 10; int a[MAX]; bool f[MAX]; bitset &lt;MAX&gt; f2[MAX]; void solve(){ int n = read(), d = read(); for(int i = 1; i &lt;= n; i++){ a[i] = read(); } sort(a + 1, a + n + 1); if(a[n] + a[n - 1] &gt; d){ puts(&quot;NO&quot;); return ; } d -= a[n]; for(int i = 0; i &lt; MAX; i++) f[i] = 0; for(int i = 0; i &lt; MAX; i++) for(int j = 0; j &lt; MAX; j++) f2[i][j] = 0; f[0] = 1; for(int i = 1; i &lt; n; i++){ for(int j = d; j &gt;= a[i]; j--){ f[j] |= f[j - a[i]]; } } f2[0][0] = 1; for(int i = 1; i &lt; n; i++){ for(int j = d + a[n]; j &gt;= 0; j--){ bitset &lt;MAX&gt; ans = f2[j]; if(j &gt;= a[i]) ans |= f2[j - a[i]]; ans |= f2[j] &lt;&lt; a[i]; f2[j] = ans; } } if(f[d]){ puts(&quot;Yes&quot;); }else{ for(int i = a[n]; i &lt;= d; i++){ int j = d + a[n] - i; if(j &lt; a[n]) continue; if(f2[i][j]){ puts(&quot;Yes&quot;); return ; } } puts(&quot;No&quot;); } } signed main(){ int t = read(); while(t--) solve(); return 0; } ","tags":[],"title":"2024-11-06-solution-cf1917e","feature":"","link":"https://WRuperD.github.io/post/2024-11-06-solution-cf1917e/","stats":{"text":"4 min read","time":198000,"words":663,"minutes":4},"date":"2024-11-06 21:25:44","dateFormat":"2024-11-06"},{"abstract":"","content":"一眼题。 由于是冒泡排序，所以我还是能比较自然的联想到排名。考虑每一轮每个数都会像最终的位置靠近一格，所以答案就是 max⁡i−ranki\\max i-rank_imaxi−ranki​。直接权值线段树随便维护维护就行了吧。 // Problem: P9596 [JOI Open 2018] 冒泡排序 2 // URL: https://www.luogu.com.cn/problem/P9596 // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 5e5 + 10; set &lt;int&gt; st[MAX * 2]; int s[MAX * 10], tag[MAX * 10], s2[MAX * 10]; int ls[MAX * 10], rs[MAX * 10]; int lsh[MAX * 2]; void pushdown(int x, int l, int r){ if(!tag[x]) return ; if(ls[x] and s2[ls[x]]) s[ls[x]] -= tag[x], s2[ls[x]] += tag[x], tag[ls[x]] += tag[x]; if(rs[x] and s2[rs[x]]) s[rs[x]] -= tag[x], s2[rs[x]] += tag[x], tag[rs[x]] += tag[x]; tag[x] = 0; } int psz; void add(int l, int r, int pos, int val, int val2, int &amp;x){ if(!x) x = ++psz; tag[x] = 0; if(l == r){ s[x] = val - val2; s2[x] = val2; return ; } int mid = (l + r) &gt;&gt; 1; if(pos &lt;= mid) add(l, mid, pos, val, val2, ls[x]); else add(mid + 1, r, pos, val, val2, rs[x]); s[x] = max(s[ls[x]], s[rs[x]]); s2[x] = max(s2[ls[x]], s2[rs[x]]); } void add2(int l, int r, int dl, int dr, int val, int &amp;x){ if(dl &gt; dr) return ; if(!x or !s2[x]) return ; if(dl &lt;= l and r &lt;= dr){ s[x] -= val; s2[x] += val; tag[x] += val; return ; } pushdown(x, l, r); int mid = (l + r) &gt;&gt; 1; if(dl &lt;= mid) add2(l, mid, dl, dr, val, ls[x]); if(dr &gt; mid) add2(mid + 1, r, dl, dr, val, rs[x]); s[x] = max(s[ls[x]], s[rs[x]]); s2[x] = max(s2[ls[x]], s2[rs[x]]); } int getrk(int l, int r, int pos, int x){ if(!x or !s2[x]) return 0; if(l == r) return s2[x]; if(r &lt;= pos) return s2[x]; pushdown(x, l, r); int mid = (l + r) &gt;&gt; 1, ans = 0; if(pos &gt; mid) ans = max(s2[ls[x]], getrk(mid + 1, r, pos, rs[x])); else ans = getrk(l, mid, pos, ls[x]); return ans; } void del(int l, int r, int pos, int val, int &amp;x){ if(l == r){ s[x] = 0; s2[x]--; st[l].erase(val); if(st[l].begin() == st[l].end()){ s2[x] = 0; return ; } auto u2 = st[l].end(); u2--; s[x] = *u2 - s2[x]; return ; } int mid = (l + r) &gt;&gt; 1; pushdown(x, l, r); if(pos &lt;= mid) del(l, mid, pos, val, ls[x]); else del(mid + 1, r, pos, val, rs[x]); s[x] = max(s[ls[x]], s[rs[x]]); s2[x] = max(s2[ls[x]], s2[rs[x]]); return ; } void upd(int l, int r, int pos, int val, int newrk, int &amp;x){ if(!x) x = ++psz; if(l == r){ s[x] = 0; st[l].insert(val); s2[x] = newrk; auto u2 = st[l].end(); u2--; s[x] = *u2 - s2[x]; return ; } int mid = (l + r) &gt;&gt; 1; pushdown(x, l, r); if(pos &lt;= mid) upd(l, mid, pos, val, newrk, ls[x]); else upd(mid + 1, r, pos, val, newrk, rs[x]); s[x] = max(s[ls[x]], s[rs[x]]); s2[x] = max(s2[ls[x]], s2[rs[x]]); return ; } int a[MAX]; pair &lt;int, int&gt; b[MAX]; struct qry{ int x, y; }; qry q2[MAX]; void solve(){ int n = read(), q = read(); int mm; for(int i = 1; i &lt;= n; i++){ a[i] = read(); lsh[++mm] = a[i]; // st[a[i]].insert(i); b[i].first = a[i], b[i].second = i; } sort(b + 1, b + n + 1); b[n + 1].first = inf; int rt = 0; // write(s[rt]), endl; for(int i = 1; i &lt;= q; i++){ q2[i].x = read(), q2[i].y = read(); lsh[++mm] = q2[i].y; } sort(lsh + 1, lsh + mm + 1); int m = unique(lsh + 1, lsh + mm + 1) - lsh - 1; for(int i = 1; i &lt;= n; i++){ a[i] = lower_bound(lsh + 1, lsh + m + 1, a[i]) - lsh; st[a[i]].insert(i); } for(int i = 1; i &lt;= n; i++){ if(b[i].first != b[i + 1].first){ add(1, m, lower_bound(lsh + 1, lsh + m + 1, b[i].first) - lsh, b[i].second, i, rt); } } int lim = m; for(int i = 1; i &lt;= q; i++){ int x = q2[i].x + 1, y = q2[i].y; y = lower_bound(lsh + 1, lsh + m + 1, y) - lsh; del(1, lim, a[x], x, rt); add2(1, lim, a[x] + 1, lim, -1, rt); // write(s[rt]), put(); int rk1 = getrk(1, lim, y, rt) + 1; // write(rk1), put(); a[x] = y; upd(1, lim, a[x], x, rk1, rt); add2 (1, lim, a[x] + 1, lim, 1, rt); write(s[rt]), endl; } } signed main(){ // freopen(&quot;sort.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;sort.out&quot;, &quot;w&quot;, stdout); int t = 1; while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"2024-11-05-solution-p9596","feature":"","link":"https://WRuperD.github.io/post/2024-11-05-solution-p9596/","stats":{"text":"7 min read","time":370000,"words":1023,"minutes":7},"date":"2024-11-05 14:59:03","dateFormat":"2024-11-05"},{"abstract":"","content":"一些有趣的网站汇总 https://youquhome.com/page/3/ 下面是一些我举得有意思的 https://frequency2156.com/ https://www.lazyfly.me/ ","tags":[],"title":"2024-11-01-鲜花","feature":"","link":"https://WRuperD.github.io/post/2024-11-01-xian-hua/","stats":{"text":"1 min read","time":8000,"words":33,"minutes":1},"date":"2024-11-01 21:09:27","dateFormat":"2024-11-01"},{"abstract":"","content":"P7070 [NWRRC2014] Kebab House 题解 模拟赛题，小清新吧。 这里是一份 O(nq2)O(n q^2)O(nq2) 的垃圾题解。 首先我们可以直接设 fi,j,kf_{i,j,k}fi,j,k​ 表示前 iii 分钟学了 jjj 分钟上一次摸鱼是在 kkk 分钟前。直接摁做是 O(nq2t)O(n q^2 t)O(nq2t) 的。 不难注意到其实 j&gt;i−(it)j &gt; i - (i \\over t)t)j&gt;i−(i​ 所以复杂度直接就对了！ 点击查看代码 // Problem: P7070 [NWRRC2014] Kebab House // URL: https://www.luogu.com.cn/problem/P7070 // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; // #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 2e3 + 10; const int MAX2 = 305; int f[2][MAX2][205]; int g[MAX2]; int mod; inline int Mod(int x){ if(x &gt;= mod) return x - mod; return x; } void solve(){ // int n = 2000, t = 200; int n = read(), t = read(); mod = 1e9 + 7; f[0][0][t + 1] = 1; if(t == 0){ while(n--){ int x = read(), y = read(); for(int i = 1; i &lt;= x; i++){ for(int j = 0; j &lt;= i; j++){ for(int k = 1; k &lt;= t + 1; k++){ f[i &amp; 1][j][k] = 0; } } for(int j = 0; j &lt;= i; j++){ for(int k = 1; k &lt;= t + 1; k++){ if(j) f[i &amp; 1][j][k] = Mod(f[i &amp; 1 ^ 1][j - 1][k] + f[i &amp; 1 ^ 1][j][k]); else f[i &amp; 1][j][k] = f[i &amp; 1 ^ 1][j][k]; } } } for(int i = 1; i &lt;= t + 1; i++) g[i] = 0; for(int j = y; j &lt;= x; j++){ for(int k = 1; k &lt;= t + 1; k++){ g[k] = Mod(g[k] + f[x &amp; 1][j][k]); } } for(int j = 0; j &lt;= x; j++) for(int k = 1; k &lt;= t + 1; k++) f[0][j][k] = f[1][j][k] = 0; // write(f[x % 2][x][t + 1]), endl; for(int i = 1; i &lt;= t + 1; i++) f[0][0][i] = g[i]; // for(int i = 1; i &lt;= t + 1; i++) write(g[i]), put(); // endl; // for(int i = 1; i &lt;= ) } int ans = 0; // write(f[0][0]) for(int i = 1; i &lt;= t + 1; i++){ ans = Mod(ans + f[0][0][i]); } write(ans), endl; return ; } while(n--){ // int x = 300, y = 300; int x = read(), y = read(); for(int i = 1; i &lt;= x; i++){ for(int j = max(0, (i - 2) - (i - 2) / max(1, t) - 1); j &lt;= i; j++){ for(int k = 1; k &lt;= t + 1; k++){ f[i &amp; 1][j][k] = 0; } } for(int j = max(0, i - i / max(1, t) - 1); j &lt;= i; j++){ for(int k = 1; k &lt;= t + 1; k++){ if(k == 1){ f[i &amp; 1][j][k] = f[i &amp; 1 ^ 1][j][t + 1]; }else{ if(k == t + 1){ if(j) f[i &amp; 1][j][k] = Mod(f[i &amp; 1 ^ 1][j - 1][k] + f[i &amp; 1 ^ 1][j - 1][k - 1]); else f[i &amp; 1][j][k] = 0; }else{ if(j) f[i &amp; 1][j][k] = f[i &amp; 1 ^ 1][j - 1][k - 1]; else f[i &amp; 1][j][k] = 0; } } } } } for(int i = 1; i &lt;= t + 1; i++) g[i] = 0; for(int j = max(y, x - x / max(1, t) - 1); j &lt;= x; j++){ for(int k = 1; k &lt;= t + 1; k++){ g[k] = Mod(g[k] + f[x &amp; 1][j][k]); } } for(int j = max(0, x - 2 - (x - 2) / max(1, t) - 1); j &lt;= x; j++) for(int k = 1; k &lt;= t + 1; k++) f[0][j][k] = f[1][j][k] = 0; // write(f[x % 2][x][t + 1]), endl; for(int i = 1; i &lt;= t + 1; i++) f[0][0][i] = g[i]; // for(int i = 1; i &lt;= t + 1; i++) write(g[i]), put(); // endl; // for(int i = 1; i &lt;= ) } int ans = 0; // write(f[0][0]) for(int i = 1; i &lt;= t + 1; i++){ ans = Mod(ans + f[0][0][i]); } write(ans ), endl; } signed main(){ // freopen(&quot;homework.in&quot;, &quot;r&quot;, stdin); // freopen(&quot;homework.out&quot;, &quot;w&quot;, stdout); int t = 1; while(t--) solve(); return 0; } ","tags":[],"title":"2024-10-31-solution-p7070","feature":"","link":"https://WRuperD.github.io/post/2024-10-31-solution-/","stats":{"text":"6 min read","time":316000,"words":879,"minutes":6},"date":"2024-10-31 15:52:56","dateFormat":"2024-10-31"},{"abstract":"","content":"ucup 做题记录。 The 3rd Universal Cup. Stage 15: Chengdu A. Arrow a Row 简单构造，吃了罚时，谢罪！ 结尾必须是至少连续三个以上的 &gt;,不然无解。然后从右往左依次填即可。 点击查看代码 #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) void solve(){ string s; cin &gt;&gt; s; int n = s.length(); s = &quot; &quot; + s; if(s[1] == '-' or s[n] == '-'){ puts(&quot;No&quot;); return ; } int cnt = 0; int mk = n + 1; for(int i = n; i &gt;= 1; i--){ if(s[i] == '-'){ if(cnt) { mk = i; break; } continue; } else{ cnt++; } } if(cnt == n or cnt &lt;= 2){ puts(&quot;No&quot;); return ; } int mk2 = 0; for(int i = 1; i &lt;= mk; i++){ if(s[i] == '&gt;'){ mk2 = i; break; } } if(!mk2){ puts(&quot;No&quot;); return ; } vector &lt;pair&lt;int,int&gt;&gt; ans; int mk3 = 0; for(int i = n - 2; i &gt;= mk; i--){ if(s[i] == '&gt;' and s[i + 1] == '&gt;' and s[i + 2] == '&gt;'){ ans.pb(make_pair(mk2, i + 2)); mk3 = i + 2; } } for(int i = mk2 + 1; i &lt;= mk; i++){ if(s[i] == '&gt;') ans.pb(make_pair(i, mk3)); } cout &lt;&lt; &quot;Yes &quot;; write(ans.size()), endl; for(int i = 0; i &lt; ans.size(); i++){ write(ans[i].first), put(), write(ans[i].second - ans[i].first + 1), endl; } return ; } signed main(){ int t = read(); while(t--) solve(); return 0; } B. Athlete Welcome Ceremony The 3rd Universal Cup. Stage 16: Nanjing Also named as: GDFTS（校内选拔赛）。教练说我校有三个队的 Ec Final 打星名额。第一次打线下 XCPC 就是 Final。牛大了。但是我怎么这场会 0 道题。给队友磕头谢罪了！ A. Hey, Have You Seen My Kangaroo? 只能说不愧是袋鼠题了。我个人心目中这场最好的题目。 首先是合并次数一定小于 nmnmnm。 考虑分类讨论，先考虑整 kkk 轮后的情况。暴力枚举每一个袋鼠 kkk 次操作后会在哪里，形成一颗外向基环树。所以第 iii 个位置上的袋鼠只会存在树高整轮。基环上的就会一直存在。不妨设第 iii 个袋鼠所代表的树高为 hih_ihi​。不妨设一直存在的袋鼠树高为正无穷。 然后你考虑模拟前 kkk 轮操作，发现对于每一次有两个位置合并，这次合并操作一定只会在 min(hu,hv)min(h_u,h_v)min(hu​,hv​) k 整轮中出现。合并后的 hhh 取更大的值。 暴力记录下这些有贡献的时间（注意总数不超过 nmnmnm)。然后就可以知道所以的答案了！ 点击查看代码 #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 2e5 + 10; int n, m, k; char a[MAX]; int b[MAX]; int g[MAX], h[MAX], deg[MAX]; int ret[MAX]; int to(int x, int y){ return (x - 1) * m + y; } pair &lt;int,int&gt; to2(int x){ return make_pair((x - 1) / m + 1, (x - 1) % m + 1); } bool chk(int x, int y){ if(x &lt;= 0 or y &lt;= 0 or x &gt; n or y &gt; m or !b[to(x,y)]) return false; return true; } inline int nxt(int x, int y){ pair &lt;int,int&gt; now = to2(x); if(a[y] == 'U'){ now.first--; } if(a[y] == 'D'){ now.first++; } if(a[y] == 'L'){ now.second--; } if(a[y] == 'R'){ now.second++; } if(chk(now.first, now.second)){ return to(now.first, now.second); } return x; } int p[MAX]; void solve(){ n = read(), m = read(), k = read(); for(int i = 1; i &lt;= k; i++){ cin &gt;&gt; a[i]; } for(int i = 1; i &lt;= n * m; i++){ char ch; cin &gt;&gt; ch; b[i] = ch - '0'; } for(int i = 1; i &lt;= n * m; i++){ if(!b[i]) continue; int now = i; for(int j = 1; j &lt;= k; j++){ now = nxt(now, j); } g[i] = now; deg[now]++; // write(to2(i).first), put(), write(to2(i).second), putchar('-'), putchar('&gt;'); // write(to2(now).first), put(), write(to2(now).second), endl; } queue &lt;int&gt; que; for(int i = 1; i &lt;= n * m; i++) if(!deg[i] and b[i]) que.push(i); while(!que.empty()){ int u = que.front(); que.pop(); deg[g[u]]--; h[u]++; h[g[u]] = max(h[g[u]], h[u]); if(!deg[g[u]]) que.push(g[u]); } for(int i = 1; i &lt;= n * m; i++){ if(deg[i]){ h[i] = inf; } } vector &lt;int&gt; ans; vector &lt;pair&lt;int,int&gt;&gt; now; for(int i = 1; i &lt;= n * m; i++) if(b[i]) now.pb(make_pair(i,i)); for(int i = 1; i &lt;= k; i++){ for(auto u : now){ u.first = nxt(u.first, i); if(p[u.first]){ int D = min(h[u.second], h[p[u.first]]); if(D == inf) { // write(i), put(); // endl; // puts(&quot;wtf?&quot;); continue; } for(int j = 1; j &lt;= D; j++){ ans.pb((j - 1) * k + i); } if(h[u.second] &gt; h[p[u.first]]){ p[u.first] = u.second; } }else{ p[u.first] = u.second; } } now.clear(); for(int j = 1; j &lt;= n * m; j++){ if(p[j]){ now.pb(make_pair(j, p[j])); } p[j] = 0; } } sort(ans.begin(), ans.end()); int now2 = 0; for(int i = 1; i &lt;= n * m; i++) if(b[i]) now2++; for(int i = 0; i &lt;= n * m; i++) ret[i] = inf; ret[now2] = 0; for(int i = 0; i &lt; ans.size(); i++){ int mk = i; for(int j = i + 1; j &lt; ans.size(); j++){ if(ans[j] != ans[i]) break; mk = j; } now2 -= (mk - i + 1); ret[now2] = ans[i]; i = mk; } for(int i = 1; i &lt;= n * m; i++){ ret[i] = min(ret[i], ret[i - 1]); } for(int i = 1; i &lt;= n * m; i++){ if(ret[i] == inf) puts(&quot;-1&quot;); else write(ret[i]), endl; } } signed main(){ int t = 1; while(t--) solve(); return 0; } 我觉得考虑整 $k$ 轮操作这一点实在是太酷了。想不到啊！ B. Birthday Gift 做了一个小时红温了。然后 dieselhuang 一眼秒了。磕头。 反转偶数位置的 0/1，发现变成了消除相邻的一对不一样的。然后就是一定能删到只剩一种数了！所以只跟数量有关! 点击查看代码 #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 2e5 + 10; // int f[MAX][3][2]; void solve(){ string s; cin &gt;&gt; s; int n = s.length(); s = &quot; &quot; + s; int cnt = 0, cnt2 = 0, cnt3 = 0; for(int i = 1; i &lt;= n; i++){ if(i % 2){ if(s[i] == '0') cnt++; else if(s[i] == '1') cnt2++; else cnt3++; }else{ if(s[i] == '1') cnt++; else if(s[i] == '0') cnt2++; else cnt3++; } } // write(cnt), put(), write(cnt2), put(), write(cnt3), endl; int chk = abs(cnt - cnt2); if(chk &gt;= cnt3){ write(chk - cnt3), endl; }else{ cnt3 -= chk; if(cnt3 % 2) puts(&quot;1&quot;); else puts(&quot;0&quot;); } } signed main(){ int t = read(); while(t--) solve(); return 0; } C. Topology 我不喜欢会做这种题目。 以下貌似是在复读官方题解。 设 fi,jf_{i,j}fi,j​ 表示不考虑 iii 子树内拓扑序的情况下 iii 在第 jjj 位的方案数。一个经典结论就是一颗树的拓扑序个数为 n!∏i=1nsizin! \\over \\prod \\limits_{i=1}^{n}siz_ii=1∏n​sizi​n!​。所以求出 fff 即可得到答案。 状态数正确。考虑如何转移？ 这里是从 ffa,x→fu,yf_{fa,x} \\to f_{u,y}ffa,x​→fu,y​ 的转移。 有两个系数。一部分是你要去钦定 uuu 子树内的节点在拓扑序内的位置。这部分系数为 (n−ysizu−1)n-y \\choose siz_u - 1(sizu​−1n−y​)。另外一部分是钦定 fafafa 子树中不在 uuu 子树中的点的拓扑序数量（可以用是上面的公式算）。 然后就是一个前缀和的形式。 时间复杂度 O(n2)O(n^2)O(n2)。 E. Left Shifting 3 签到题。 最多左移 7 次。 点击查看代码 #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 2e5 + 10; char s[MAX]; void solve(){ int n = read(), k = read(); for(int i = 1; i &lt;= n; i++) cin &gt;&gt; s[i]; int ans = 0; for(int i = 1; i &lt;= n - 6; i++){ if(s[i] == 'n' and s[i + 1] == 'a' and s[i + 2] == 'n' and s[i + 3] == 'j' and s[i + 4] == 'i' and s[i + 5] == 'n' and s[i + 6] == 'g'){ ans++; } } for(int j = 1; j &lt;= min(k, 7ll); j++){ for(int i = 1; i &lt; n; i++){ swap(s[i], s[i + 1]); } int cnt = 0; for(int i = 1; i &lt;= n - 6; i++){ if(s[i] == 'n' and s[i + 1] == 'a' and s[i + 2] == 'n' and s[i + 3] == 'j' and s[i + 4] == 'i' and s[i + 5] == 'n' and s[i + 6] == 'g'){ cnt++; } } ans = max(ans, cnt); } write(ans), endl; } signed main(){ int t = read(); while(t--) solve(); return 0; } G. Binary Tree 简单题。膜拜 yinhee 首杀。 拎出树的中心。如果度数为 0 或 1 那么直接问吧。否则问大小最大的两颗子树的根。不难发现问题至少会被缩小至 n2n\\over 22n​ 解决。 I. Bingo 不会一点 poly. 但是可以归约到给你 n⋅mn \\cdot mn⋅m 的方格选 kkk 个格子涂黑要求每行每列必须至少有一个黑格子的方案数。需要知道 k≤200000k \\leq 200000k≤200000 的所有值。 J. Social Media 简单讨论一下就行了。 K. Strips 直接贪心然后调整一下。 ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"},{"name":"学习笔记","slug":"qWhunhKoya","used":true,"link":"https://WRuperD.github.io/tag/qWhunhKoya/"}],"title":"A Moon Shaped Pool","feature":"https://WRuperD.github.io/post-images/a-moon-shaped-pool.jpg","link":"https://WRuperD.github.io/post/a-moon-shaped-pool/","stats":{"text":"13 min read","time":754000,"words":2350,"minutes":13},"date":"2024-10-30 15:58:53","dateFormat":"2024-10-30"},{"abstract":"","content":"CF2003E1 Turtle and Inversions (Easy Version) 题解 Tester 题解。一个冷知识是这dao'ti如果我没有记错的话这道题原本是在 D 的位置的。不是很懂为啥赛时这么少人过啊。我很快就胡出来了啊。 晚些时候再写！ ","tags":[],"title":"2024-10-30-solution-cf2003e1","feature":"","link":"https://WRuperD.github.io/post/2024-10-30-solution-cf2003e1/","stats":{"text":"1 min read","time":15000,"words":70,"minutes":1},"date":"2024-10-30 11:51:11","dateFormat":"2024-10-30"},{"abstract":"","content":"CF1305F Kuroni and the Punishment 题解 这个在看到标签有随机化后确实是一眼吧。 首先答案肯定有一个上街就是奇数个数 ≤n\\leq n≤n。这也就意味着至少有 ≤n2\\leq n\\over 22≤n​ 个数只被操作了 ≤2\\leq 2≤2 次。于是我们随机选一个数他被操作了 1 或 0 次的概率就是 121\\over 221​。设我们随机 BBB 个数找他们的质因数。那么错误概率就是 12B1\\over 2^B2B1​。 // Problem: Kuroni and the Punishment // URL: https://www.luogu.com.cn/problem/CF1305F // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 2e5 + 10; int a[MAX]; std::mt19937 Rnd(114514); map &lt;int, int&gt; mp; vector &lt;int&gt; b; void solve(){ int n = read(); int ans = 0; for(int i = 1; i &lt;= n; i++){ a[i] = read(); ans += a[i] % 2; // if(a[i] != 1 and n &gt; 10) { // write(a[i]), put(); // endl; // } } int now = a[1]; for(int i = 2; i &lt;= n; i++){ now = __gcd(now, a[i]); } if(now != 1){ puts(&quot;0&quot;); return ; } int t = 40; while(t--){ int x2 = Rnd() % n + 1; // write(x2), endl; for(int k = a[x2] - 1; k &lt;= a[x2] + 1; k++){ int x = k; for(int i = 2; i * i &lt;= x; i++){ if(x % i) continue; while(x % i == 0) x /= i; if(mp.count(i)) continue; mp[i] = 1; b.pb(i); } if(x &gt;= 2){ if(mp.count(x)) continue; mp[x] = 1; b.pb(x); } } } for(int u : b){ int cnt = 0; for(int i = 1; i &lt;= n; i++){ if(a[i] &lt;= u){ cnt += u - a[i]; }else{ cnt += min(a[i] % u, u - (a[i] % u)); } } // write(1); ans = min(ans, cnt); } write(ans), endl; } signed main(){ int t = 1; while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"2024-10-30-solution-cf1305f","feature":"","link":"https://WRuperD.github.io/post/2024-10-30-solution-cf1305f/","stats":{"text":"3 min read","time":157000,"words":466,"minutes":3},"date":"2024-10-30 11:26:14","dateFormat":"2024-10-30"},{"abstract":"","content":"CF1027F Session in BSU 题解 duel 题，居然输了 /tuu。 这个就是你考虑可以合理转换 每次只能填 ai−1+1a_{i-1}+1ai−1​+1 或者 000 然后给定 a1a_1a1​。然后就是你无脑 dp 维护构造的转移点。这部分的时间复杂度是 O(nn)O(n\\sqrt n)O(nn​)。然后构造就是前面特殊的直接美剧和后面稍微拼一下。 // Problem: Modular Sequence // URL: https://www.luogu.com.cn/problem/CF1928E // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 2e5 + 10; int f[MAX]; bool fl = 0; int lst[MAX]; int testcase = 0; void solve(){ testcase++; int n = read(), x = read(), y = read(), s = read(); if(testcase == 10779 and fl){ write(n), write(x), put(), put(), write(y), put(), write(s), endl; } if(fl) return ; int x2 = x % y; if((s - x2 * n - (x - x2)) % y){ puts(&quot;NO&quot;); return ; } int lft = (s - x2 * n - (x - x2)) / y; if(lft &lt; 0){ puts(&quot;NO&quot;); return ; } vector &lt;int&gt; a; a.pb(x); int now = x / y + 1; if(f[lft] &lt;= n - 1){ while(lft){ now = 0; int prelft = lft; for(int i = 0; i &lt;= lst[prelft]; i++){ a.pb(now * y + x2); lft -= now; now++; } } while(a.size() &lt; n) a.pb(x2); puts(&quot;YES&quot;); for(int i = 0; i &lt; n; i++) write(a[i]), put(); endl; return ; }else{ for(int k = 2; k &lt;= n; k++){ if(now &lt;= lft){ a.pb(now * y + x2); lft -= now; now++; if(f[lft] &lt;= (n - k)){ while(lft){ now = 0; int prelft = lft; for(int i = 0; i &lt;= lst[prelft]; i++){ a.pb(now * y + x2); lft -= now; now++; } } while(a.size() &lt; n) a.pb(x2); puts(&quot;YES&quot;); for(int i = 0; i &lt; n; i++) write(a[i]), put(); endl; return ; } } else { puts(&quot;NO&quot;); return ; } } puts(&quot;NO&quot;); return ; } puts(&quot;YES&quot;); for(int i = 0; i &lt; n; i++) write(a[i]), put(); endl; } signed main(){ f[0] = 0; for(int i = 1; i &lt; MAX; i++){ int pre = 0; f[i] = inf; for(int j = 1; pre &lt;= i; j++){ pre += j - 1; if(pre &gt; i) break; if(f[i] &gt; f[i - pre] + j){ lst[i] = j - 1; } f[i] = min(f[i], f[i - pre] + j); } } int t = read(); while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"2024-10-28-solution-cf1027f","feature":"","link":"https://WRuperD.github.io/post/2024-10-28-solution-cf1027f/","stats":{"text":"4 min read","time":192000,"words":551,"minutes":4},"date":"2024-10-28 19:03:51","dateFormat":"2024-10-28"},{"abstract":"","content":"小清新好题。连边 ai,bia_i,b_iai​,bi​ 如果一个连通块 m&gt;nm &gt; nm&gt;n 显然无解否则只剩下是树或者基环树。基环树的情况顶满最大值，树的情况是次小值。 // Problem: Session in BSU // URL: https://www.luogu.com.cn/problem/CF1027F // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 1e6 + 10; int a[MAX], b[MAX]; int lsh[MAX * 2]; bool vis[MAX &lt;&lt; 1]; int cnt, cnt2; int maxn, maxn2; vector &lt;int&gt; g[MAX &lt;&lt; 1]; void dfs(int u){ vis[u] = 1; cnt++; if(maxn &lt; u){ maxn2 = maxn; maxn = u; }else{ maxn2 = max(maxn2, u); } for(int v : g[u]){ cnt2++; if(!vis[v]) dfs(v); } } void solve(){ int n = read(); for(int i = 1; i &lt;= n; i++){ a[i] = read(), b[i] = read(); lsh[2 * i - 1] = a[i], lsh[2 * i] = b[i]; } sort(lsh + 1, lsh + 2 * n + 1); int m = unique(lsh + 1, lsh + 2 * n + 1) - lsh - 1; for(int i = 1; i &lt;= n; i++) a[i] = lower_bound(lsh + 1, lsh + m + 1, a[i]) - lsh; for(int i = 1; i &lt;= n; i++) b[i] = lower_bound(lsh + 1, lsh + m + 1, b[i]) - lsh; for(int i = 1; i &lt;= n; i++){ g[a[i]].pb(b[i]); g[b[i]].pb(a[i]); } int ans = 0; for(int i = 1; i &lt;= m; i++){ if(!vis[i]){ cnt = cnt2 = 0; maxn = maxn2 = 0; dfs(i); cnt2 /= 2; if(cnt == cnt2 + 1){ ans = max(ans, maxn2); }else if(cnt == cnt2){ ans = max(ans, maxn); }else{ puts(&quot;-1&quot;); exit(0); } // write(cnt), put(), write(cnt2), endl; } } // write(ans), endl; write(lsh[ans]), endl; } signed main(){ int t = 1; while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"2024-10-28-soltuion-cf1027f","feature":"","link":"https://WRuperD.github.io/post/2024-10-28-soltuion-cf1027f/","stats":{"text":"3 min read","time":153000,"words":431,"minutes":3},"date":"2024-10-28 18:12:57","dateFormat":"2024-10-28"},{"abstract":"","content":"CF733F Drivers Dissatisfaction 题解 Yet Another Div2f. duel 题。 简单题目。首先肯定是只能在一条边上操作的。然后就相当于钦定一条边的最小生成树。相当于减去原最小生成树上 u,vu,vu,v 路径中的最大值。考虑直接 kruskal 重构树解决。 // Problem: Drivers Dissatisfaction // URL: https://www.luogu.com.cn/problem/CF733F // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 2e5 + 10; struct node{ int u, v, w, w2; int id; }; node edg[MAX]; int psz; int fa[MAX * 4]; int val[MAX * 4], val2[MAX * 4]; int find(int x){ if(fa[x] == x) return x; return fa[x] = find(fa[x]); } vector &lt;int&gt; g2[MAX * 10]; int fat[MAX * 4], siz[MAX * 4], son[MAX * 4]; int dep[MAX * 4]; void dfs(int u){ siz[u] = 1; for(int v : g2[u]){ fat[v] = u, dep[v] = dep[u] + 1; dfs(v); siz[u] += siz[v]; if(siz[son[u]] &lt; siz[v]) son[u] = v; } } int top[MAX]; void dfs2(int u, int topu){ top[u] = topu; if(son[u]) dfs2(son[u], topu); for(int v : g2[u]){ if(v != son[u]) dfs2(v, v); } } int lca(int u, int v){ while(top[u] != top[v]){ if(dep[top[u]] &lt; dep[top[v]]) swap(u, v); u = fat[top[u]]; } return dep[u] &lt; dep[v] ? u : v; } bool cmp(node x, node y){ if(x.w != y.w){ return x.w &lt; y.w; } return x.w2 &lt; y.w2; } bool vis[MAX]; void solve(){ int n = read(), m = read(); for(int i = 1; i &lt;= m; i++){ edg[i].w = read(); edg[i].id = i; } for(int i = 1; i &lt;= m; i++){ edg[i].w2 = read(); } for(int i = 1; i &lt;= m; i++){ edg[i].u = read(), edg[i].v = read(); } sort(edg + 1, edg + m + 1, cmp); for(int i = 1; i &lt;= n; i++) fa[i] = i; psz = n; int ans = 0; for(int i = 1; i &lt;= m; i++){ if(find(edg[i].u) == find(edg[i].v)) continue; vis[i] = 1; ans += edg[i].w; g2[++psz].pb(find(edg[i].u)); g2[psz].pb(find(edg[i].v)); fa[find(edg[i].u)] = fa[find(edg[i].v)] = psz; fa[psz] = psz; val[psz] = edg[i].w; val2[psz] = i; } int S = read(); // write(S), endl; int rt = find(1); dfs(rt); dfs2(rt, rt); int realans = inf; // write(ans), endl; int mk = 0; for(int i = 1; i &lt;= m; i++){ int now = ans; if(vis[i]){ // write(edg[i].w), put(), write(edg[i].w2), endl; now -= S / edg[i].w2; // write(now), endl; if(realans &gt; now){ realans = now; mk = i; } // ans = min(ans, now); }else{ now -= val[lca(edg[i].u, edg[i].v)]; // write(lca(edge)) now += edg[i].w; now -= S / edg[i].w2; // write(now), endl; if(realans &gt; now){ realans = now; mk = i; } } } write(realans), endl; if(vis[mk]){ for(int i = 1; i &lt;= m; i++){ if(vis[i]){ write(edg[i].id), put(); if(i == mk){ write(edg[i].w - S / edg[i].w2), endl; }else{ write(edg[i].w), endl; } } } return ; } vis[val2[lca(edg[mk].u, edg[mk].v)]] = 0; for(int i = 1; i &lt;= m; i++){ if(vis[i]){ write(edg[i].id), put(); if(i == mk){ write(edg[i].w - S / edg[i].w2), endl; }else{ write(edg[i].w), endl; } } if(i == mk){ write(edg[i].id), put(); if(i == mk){ write(edg[i].w - S / edg[i].w2), endl; }else{ write(edg[i].w), endl; } } } return ; } signed main(){ int t = 1; while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"2024-10-28-solution-cf733f","feature":"","link":"https://WRuperD.github.io/post/2024-10-28-solution-cf733f/","stats":{"text":"5 min read","time":272000,"words":758,"minutes":5},"date":"2024-10-28 11:36:01","dateFormat":"2024-10-28"},{"abstract":"","content":"[ARC127E] Priority Queue 题解 感觉非常的高妙啊。 大致就是不妨钦定最后剩下的序列有序。 后面再补。 // Problem: [ARC127E] Priority Queue // URL: https://www.luogu.com.cn/problem/AT_arc127_e // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 5e3 + 10; const int mod = 998244353; int a[MAX]; int f[MAX][MAX]; void solve(){ int n = read(), m = read(); int n2 = 0, now = 0; for(int i = 1; i &lt;= n + m; i++){ int op = read(); if(op == 1) a[++n2] = ++now; else n2--; } for(int i = 0; i &lt;= now; i++) f[0][i] = 1; for(int i = 1; i &lt;= n2; i++){ for(int j = 1; j &lt;= a[i]; j++){ f[i][j] = (f[i - 1][j - 1] + f[i][j - 1]) % mod; } for(int j = a[i] + 1; j &lt;= now; j++) f[i][j] = f[i][a[i]]; } write(f[n2][a[n2]]), endl; } signed main(){ int t = 1; while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"2024-10-28-solution-arc127e","feature":"","link":"https://WRuperD.github.io/post/2024-10-28-solution-arc127e/","stats":{"text":"2 min read","time":101000,"words":285,"minutes":2},"date":"2024-10-28 10:00:13","dateFormat":"2024-10-28"},{"abstract":"<p>摘要：本文使用了<a href=\"https://www.acwing.com/file_system/file/content/whole/index/content/12569272/\">该博客的方法</a>介绍了如何在考场 5min 之内搓出 sublime 的配置。</p>\n","content":"摘要：本文使用了该博客的方法介绍了如何在考场 5min 之内搓出 sublime 的配置。 效果图：右上是样例文件，右下是你的输出。 首先先看如何调成图上界面的模样。 先点击：alt+shift+2 然后 点击上方的 view-&gt;group-&gt;newgroup 即可。 然后使用文件操进行输入输出就可以了。 接下来我们用 该博客的方法 就可以在 1min 之内配置好环境。该方法在 windows 环境下同样适用。你可以讲 .package 暴力变为 .zip 然后就可以看了。 ","tags":[{"name":"鲜花","slug":"tMU1QJpF3","used":true,"link":"https://WRuperD.github.io/tag/tMU1QJpF3/"}],"title":"加入 sublime 邪教！ ","feature":"","link":"https://WRuperD.github.io/post/jia-ru-sublime-xie-jiao/","stats":{"text":"1 min read","time":32000,"words":152,"minutes":1},"date":"2024-10-25 17:07:55","dateFormat":"2024-10-25"},{"abstract":"","content":" 2024-10-23 已经精神开摆了。模拟赛直接打摆。还好后面两天没有模拟赛了。 学弟发现了一个贼牛逼的网站，https://viggle.ai/。非常好玩。如图，是学弟，不是我。 更快速的链接 2024-10-24 彻底开摆了。一道题没做。 研究了一下 NOI Linux2。发现了绝妙文章 https://www.cnblogs.com/PeppaEvenPig/p/18263178. sublime 太好用了!. 还是挺奇怪的，感觉每次考试前脑子都会莫名其妙回忆起一些歌开始播放。 我记得中考的时候是 final masquerade。 现在满脑子都是 2024-10-25 不知道为什么 xp 一直在机房。然后就坐大牢了。 研究了如何使用 sublime，非常好！。 2024-10-26 上午一直在谷歌地图开车闲逛，最后一小时在和 @yinhee duel 图寻。 下午来了。大致就是 100 + 100 + 50 +0 了。大致就是 T2 扔掉包含区间写了 1.5 小时。大致就是 T3 不会做，哈哈。大致是没希望了。 2024-10-27 用 100 尘合成了 40 宇宙彩虹 DK。非常好玩！一把 30min 让我迟到了。 ARC 连 A 都不会，这辈子有了！ 2024-10-28 今天又摆了一天烂，做了一些低难度题目。 感觉状态奇烂无比。就这样。 模拟赛 T1 做了 2h。 2024-10-29 模拟赛 T1 做了 1min。然后获得了一上午的精致睡眠。 恭喜罗德里获得金球奖！ 今天连简单题都没写了。 CSP-S T3 蠢飞了，我用了大家赛时 O(n2)O(n^2)O(n2) 到 O(n)O(n)O(n) 的方法把我的 dp O(n3)O(n^3)O(n3) -&gt; O(n2)O(n^2)O(n2) 丝毫没有意识到有一个 nnn 是我凭空加的。哈哈。 2024-10-30 终于配置上了我认为最好看的主题 catppuccin-latte. 没有模拟赛，又摆了一天。 开坑了 http://wruperd.github.io/post/a-moon-shaped-pool/ 。 2024-10-31 ","tags":[{"name":"鲜花","slug":"tMU1QJpF3","used":true,"link":"https://WRuperD.github.io/tag/tMU1QJpF3/"}],"title":"2024 CSP 前后杂谈","feature":"https://WRuperD.github.io/post-images/2024-csp-za-tan.bmp","link":"https://WRuperD.github.io/post/2024-csp-za-tan/","stats":{"text":"2 min read","time":116000,"words":490,"minutes":2},"date":"2024-10-23 20:04:15","dateFormat":"2024-10-23"},{"abstract":"","content":"CF2023D Many Games 题解 非常像我会做的题目。要是我打 CF 的时候不去吃完饭，不打摆感觉还是非常有机会做出来的。 首先考虑什么样的物品才能使答案增大。不妨设当前的 ∏ipi100=X,∑iwi=Y\\prod\\limits_i {p_i\\over 100} = X,\\sum\\limits_i w_i = Yi∏​100pi​​=X,i∑​wi​=Y。 XY&lt;Xpi100(Y+wx)Y&lt;pi100(Y+wx)Y&lt;pi100Y+pi100wx(1−pi100)Y&lt;pi100wxY&lt;pi100wx(1−pi100)Y&lt;pi⋅wx(100−pi)\\begin{aligned} XY &lt;&amp; X {p_i \\over 100} (Y+w_x)\\\\ Y &lt;&amp; {p_i \\over 100} (Y+w_x)\\\\ Y &lt;&amp; {p_i \\over 100} Y+{p_i \\over 100}w_x\\\\ (1-{p_i \\over 100})Y &lt;&amp; {p_i \\over 100}w_x\\\\ Y &lt;&amp; {{p_i \\over 100}w_x \\over (1-{p_i \\over 100})}\\\\ Y &lt;&amp; {p_i \\cdot w_x \\over (100-p_i)}\\\\ \\end{aligned} XY&lt;Y&lt;Y&lt;(1−100pi​​)Y&lt;Y&lt;Y&lt;​X100pi​​(Y+wx​)100pi​​(Y+wx​)100pi​​Y+100pi​​wx​100pi​​wx​(1−100pi​​)100pi​​wx​​(100−pi​)pi​⋅wx​​​ 所以我们得出结论当当前重量大于 2.1⋅1052.1 \\cdot 10^52.1⋅105 左右时必然不会有新增的物品。（赛时怎么到这里就直接莽上去了qwq）。 如果你按照 pip_ipi​ 分组，按照 wiw_iwi​ 从大到小排序的话，我们每次一定是取一段前缀。猜想这个前缀的长度并不长，原因也比较简单，就是考虑当前加进去 www 要更优。 pk⋅W&lt;pk+1⋅(W+minw)≤pk+1⋅Wk+1kp&gt;k+1kkp&gt;k+1k&gt;1p−1k&lt;100100−pi \\begin{aligned} p^k \\cdot W &amp;&lt; p^{k+1} \\cdot (W+minw) \\\\ &amp;\\leq p^{k+1} \\cdot W {k+1\\over k} \\\\ p &amp;&gt; {k+1 \\over k} \\\\ kp &amp; &gt; k+1\\\\ k &amp; &gt; {1\\over p-1} \\\\ k &amp; &lt; {100 \\over 100 - p_i} \\\\ \\end{aligned}pk⋅Wpkpkk​&lt;pk+1⋅(W+minw)≤pk+1⋅Wkk+1​&gt;kk+1​&gt;k+1&gt;p−11​&lt;100−pi​100​​ 所以你照着取一起下物品总数是极少的。最后你直接做一个背包就行了。 // Problem: Many Games // URL: https://www.luogu.com.cn/problem/CF2023D // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 21e4 + 10; double f[MAX]; priority_queue &lt;int&gt; que[MAX]; void solve(){ int n = read(); double preans = 0; for(int i = 1; i &lt;= n; i++){ int p = read(), w = read(); if(p == 100){ preans += w; }else{ que[p].push(w); } } f[0] = 1.0; for(int i = 1; i &lt;= 99; i++){ int lim = 100 / (100 - i) + 1; while(!que[i].empty() and lim--){ int u = que[i].top(); que[i].pop(); for(int j = MAX - 10; j &gt;= u; j--){ f[j] = max(f[j], f[j - u] * (double)(i) / 100.0); } } } double ans = 0; for(int i = 0; i &lt; MAX; i++){ ans = max(ans, double(i + preans) * f[i]); } printf(&quot;%.7f\\n&quot;, ans); } signed main(){ int t = 1; while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"2024-10-22-solution-cf2023d ","feature":"","link":"https://WRuperD.github.io/post/2024-10-22-solution-cf2023d/","stats":{"text":"4 min read","time":234000,"words":717,"minutes":4},"date":"2024-10-22 19:27:59","dateFormat":"2024-10-22"},{"abstract":"","content":"CF2030D QED's Favorite Permutation 题解 CodeFancy 好喜欢考察这个 Trick 啊，已经见到第三次了。 首先手玩可以发现，不能交换两个位置 i,ji,ji,j 上的数当且仅当 x∈[i,j),sx=L,sx+1=Rx \\in [i,j),s_x = L,s_{x+1} = Rx∈[i,j),sx​=L,sx+1​=R。转换一下视角，由于是看全局能不能排序，所以我们可以预处理哪些位置 xxx 满足 sx=L,sx+1=Rs_x=L,s_{x+1}=Rsx​=L,sx+1​=R 的条件会使得答案为否。这个可以直接对于每一个 [min⁡(ai,i),max⁡(ai,i))[\\min(a_i,i),\\max(a_i,i))[min(ai​,i),max(ai​,i)) 差分去打一个区间加标记来解决。 然后对于每一次单点修改你就更新一下 x,x−1x,x-1x,x−1 这两个位置对答案的贡献就行了。复杂度是 O(n)O(n)O(n)。 // Problem: D. QED's Favorite Permutation // URL: https://codeforces.com/contest/2030/problem/D // Writer:WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 5e5 + 10; int a[MAX]; int s2[MAX]; void solve(){ int n = read(), m = read(); for(int i = 1; i &lt;= n; i++){ a[i] = read(); } string s; cin &gt;&gt; s; int l = 1, r = 0; for(int i = 1; i &lt;= n; i++){ s2[i] = 0; } for(int i = 1; i &lt;= n; i++){ int L = min(a[i], i), R = max(a[i], i); s2[L]++; s2[R]--; } int now = 0; for(int i = 1; i &lt;= n; i++){ now += s2[i]; s2[i] = now; } // while(a[l] == l and l &lt;= n){ // l++; // } // while(a[r] == r and r &gt;= 1){ // r--; // } // // write(l), endl; // if(l == n + 1){ // while(m--){ // int x = read(); // puts(&quot;YES&quot;); // } // return ; // } int cnt = 0; for(int i = 1; i &lt; n; i++){ if(s2[i] and s[i - 1] == 'L' and s[i] == 'R'){ cnt++; } } while(m--){ int x = read(); // if(x &lt; l or x &gt; r){ // if(cnt) puts(&quot;NO&quot;); // else puts(&quot;YES&quot;); // continue; // } int pre = 0; if(s2[x - 1]) pre += (s[x - 2] == 'L' and s[x - 1] == 'R'); if(s2[x]) pre += (s[x - 1] == 'L' and s[x] == 'R'); int now = 0; if(s[x - 1] == 'L') s[x - 1] = 'R'; else s[x - 1] = 'L'; if(s2[x - 1]) now += (s[x - 2] == 'L' and s[x - 1] == 'R'); if(s2[x]) now += (s[x - 1] == 'L' and s[x] == 'R'); cnt += now - pre; // write(cnt), put(), write(pre), endl; if(cnt){ puts(&quot;NO&quot;); }else{ puts(&quot;YES&quot;); } } } signed main(){ int t = read(); while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"2024-10-22-solution-cf2030d","feature":"","link":"https://WRuperD.github.io/post/2024-10-22-solution-cf2030d/","stats":{"text":"4 min read","time":211000,"words":631,"minutes":4},"date":"2024-10-22 19:06:33","dateFormat":"2024-10-22"},{"abstract":"","content":"CF2030E MEXimize the Score 题解 上 CM 了，纪念一下。 考虑从小到大对于每一种数字算贡献。 设 fi,jf_{i,j}fi,j​ 表示有 jjj 个 ax=ia_x = iax​=i 对答案产生了 1 的贡献的方案数。那么显然有: fi,j=∑k&gt;jfi−1,k⋅(cntij)+fi−1,j⋅∑k≥j(cntik)f_{i,j} = \\sum \\limits_{k &gt; j} f_{i-1,k}\\cdot{cnt_i \\choose j} + f_{i-1,j}\\cdot \\sum \\limits_{k\\geq j} {cnt_i \\choose k} fi,j​=k&gt;j∑​fi−1,k​⋅(jcnti​​)+fi−1,j​⋅k≥j∑​(kcnti​​) 那么最后的答案就是 ∑fi,j⋅j\\sum f_{i,j} \\cdot j∑fi,j​⋅j。 乍一看这个柿子是 O(n2)O(n^2)O(n2) 的对吧，但是实际上首先转移可以前缀和优化做到 O(1)O(1)O(1)，其次有效注意到第二维是有一个上界为 min⁡j≤i(cntj)\\min \\limits_{j\\leq i} (cnt_j)j≤imin​(cntj​) 的，而 ∑cnti=n\\sum cnt_i = n∑cnti​=n。那么这样子其实第二维的有效状态数就是 O(n)O(n)O(n) 的了。直接写就完事了。 // Problem: E. MEXimize the Score // URL: https://codeforces.com/contest/2030/problem/E // Writer:WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 2e5 + 10; const int mod = 998244353; int cnt[MAX]; int f[MAX]; int pre2[MAX]; int preasd[MAX]; int inv123[MAX]; int F114[MAX]; int a[MAX]; int quickPower(int a,int b,int p){int base=a,ans=1;while(b){if(b&amp;1)ans*=base,ans%=p;base*=base;base%=p;b&gt;&gt;=1;}return ans;} int c2(int n, int m){ if(m &gt; n) return 0; return preasd[n] * F114[m] % mod * F114[n-m] % mod; } void solve(){ int n = read(); pre2[0] = 1; for(int i = 1; i &lt;= n; i++){ pre2[i] = pre2[i - 1] * 2 % mod; a[i] = read(); cnt[a[i]]++; } int premin = n; for(int i = 0; i &lt;= n + 1; i++) f[i] = 0; f[n] = 1; int ans = 0; int pree2 = n; for(int i = 0; i &lt; n; i++){ if(!cnt[i]){ break; } int pre = 0; pree2 = pree2 - cnt[i]; int pree3 = 0; for(int j = premin + 1; j &lt;= cnt[i]; j++){ pree3 = (pree3 + c2(cnt[i], j)) % mod; } for(int j = premin; j &gt;= 1; j--){ int prefj = f[j]; f[j] = pre * c2(cnt[i], j) % mod; pree3 = (pree3 + c2(cnt[i], j)) % mod; f[j] = (f[j] + prefj * pree3 % mod) % mod; pre = (pre + prefj) % mod; // write(i), put(), write(j), put(), write(ans), put(), write(f[j]), put(), write(pree2), endl; ans = (ans + f[j] * pre2[pree2] % mod * j % mod) % mod; } premin = min(premin, cnt[i]); } for(int i = 0; i &lt;= n; i++) cnt[i] = 0; write(ans), endl; } signed main(){ preasd[0] = F114[0] = 1; preasd[1] = inv123[1] = F114[1] = 1; for(int i = 2; i &lt; MAX; i++){ preasd[i] = 1ll * preasd[i - 1] * i % mod; inv123[i] = 1ll * inv123[mod % i] * (mod - mod / i) % mod; F114[i] = 1ll * F114[i - 1] * inv123[i] % mod; } int t = read(); while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"2024-10-22-solution-cf2030e","feature":"","link":"https://WRuperD.github.io/post/2024-10-22-solution-cf2030e/","stats":{"text":"5 min read","time":241000,"words":704,"minutes":5},"date":"2024-10-22 18:46:22","dateFormat":"2024-10-22"},{"abstract":"","content":"The 3rd Universal Cup. Stage 13: Sendai Problem O Sub Brackets 题解 没想到这辈子还能在 ucup 场上场切中档题。成功拿到了 8点 开的队中的首 A. 不知道为啥 AT 上是 *2785。 这个题大致就是你发现两个区间的交长度为偶数一定可以。构造形如 ()()()() 这样就行了。而如果交的长度为奇数就一定不行。这个可以写一个爆搜验证一下。 注意到 n≤500n \\leq 500n≤500 所以我们直接暴力检查性质，暴力建图跑一个最小割就可以过了。 // Problem: P - Sub Brackets // URL: https://atcoder.jp/contests/tupc2023/tasks/tupc2023_p // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 1010; struct node{ int l, r; }; node a[MAX]; int psz = 2; struct flow{ struct node{ int v, w, cp; }; vector &lt;node&gt; g[MAX]; int dis[MAX]; bool bfs(int s, int t){ for(int i = 1; i &lt;= psz; i++) dis[i] = inf; dis[s] = 0; queue &lt;int&gt; q; q.push(s); while(!q.empty()){ int u = q.front(); q.pop(); for(auto V : g[u]){ if(V.w &gt; 0 and dis[V.v] &gt; dis[u] + 1){ dis[V.v] = dis[u] + 1; q.push(V.v); } } } if(dis[t] == inf) return 0; return 1; } int cur[MAX]; int aug(int u, int now, int t){ if(u == t) return now; int ans = 0; for(int &amp;i = cur[u]; i &lt; g[u].size(); i++){ int v = g[u][i].v, w = g[u][i].w, cp = g[u][i].cp; if(dis[v] != dis[u] + 1) continue; int ret = aug(v, min(w, now), t); g[u][i].w -= ret, g[v][cp].w += ret; now -= ret, ans += ret; if(now &lt;= 0) break; } return ans; } void add_edge(int u, int v, int w){ g[u].pb(node{v, w, g[v].size()}); g[v].pb(node{u, 0, g[u].size() - 1}); } }; flow g; int ins[MAX], ous[MAX]; void solve(){ int n = read(), m = read(); for(int i = 1; i &lt;= m; i++){ a[i].l = read(), a[i].r = read(); } int s = 1, t = 2; // psz = 3; for(int i = 1; i &lt;= m; i++){ ins[i] = ++psz; ous[i] = ++psz; } for(int i = 1; i &lt;= m; i++){ for(int j = 1; j &lt;= m; j++){ int L = max(a[i].l, a[j].l); int R = min(a[i].r, a[j].r); int len = max(0ll, R - L + 1); if(len % 2){ g.add_edge(ins[i], ous[j], inf); } } } for(int i = 1; i &lt;= m; i++){ g.add_edge(s, ins[i], 1); g.add_edge(ous[i], t, 1); } int ans = 0; while(g.bfs(s, t)){ for(int i = 1; i &lt;= psz; i++) g.cur[i] = 0; ans += g.aug(s, inf, t); } // write(ans), endl; write(m - ans / 2), endl; } signed main(){ int t = 1; while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"2024-10-21-solution-ucup-season3-stage13-sendai-problemO","feature":"","link":"https://WRuperD.github.io/post/2024-10-21-solution-ucup-season3-stage13-sendai-problemo/","stats":{"text":"4 min read","time":224000,"words":659,"minutes":4},"date":"2024-10-21 20:29:08","dateFormat":"2024-10-21"},{"abstract":"","content":"2023Meta Hacker Cup Problem C: Krab-otage 题解 大粪题。但是思路还是比较清新的。 上图中，红色格子代表删掉的格子。那么最终答案一定是某一个 (1,1)(1,1)(1,1) 到蓝色格子的路径最大值加上某一个绿色格子到 (r,c)(r,c)(r,c) 路径的最大值。 于是我们考虑动态规划转移红色位置，转移形式大致是枚举拐角处，然后把所有已经确定是蓝色格子和已经确定是绿色格子的贡献加入答案。分类讨论亿下就行了，很恶心。 #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 1e6 + 10; const int mod = 998244353; int quickPower(int a,int b,int p){int base=a,ans=1;while(b){if(b&amp;1)ans*=base,ans%=p;base*=base;base%=p;b&gt;&gt;=1;}return ans;} int a[MAX]; int prea[MAX]; int cnt0[MAX], cnt1[MAX], cnt2[MAX], cnt3[MAX]; int ans; void dfs(int l, int r, int x){ if(x &gt; r){ bool fl = 0; for(int i = l; i &lt;= r; i++){ for(int j = i + 1; j &lt;= r; j++){ for(int k = j + 2; k &lt;= r; k++){ if(a[i] == a[j] or a[i] == a[k] or a[j] == a[k]) continue; fl = 1; break; } } } if(fl) return ; for(int i = l; i &lt;= r; i++){ for(int j = i + 2; j &lt;= r; j++){ for(int k = j + 1; k &lt;= r; k++){ if(a[i] == a[j] or a[i] == a[k] or a[j] == a[k]) continue; fl = 1; break; } } } if(fl) return ; ans++; return ; } if(a[x] == 1) dfs(l, r, x + 1); else if(a[x] == 2) dfs(l, r, x + 1); else if(a[x] == 3) dfs(l, r, x + 1); else{ a[x] = 1; dfs(l, r, x + 1); a[x] = 2; dfs(l, r, x + 1); a[x] = 3; dfs(l, r, x + 1); a[x] = 0; } } void solve2(int l, int r){ ans = 0; dfs(l, r, l); write(ans), endl; } void solve(){ freopen(&quot;sub.in&quot;, &quot;r&quot;, stdin); freopen(&quot;sub.out&quot;, &quot;w&quot;, stdout); int n = read(), q = read(); for(int i = 1; i &lt;= n; i++){ a[i] = read(); cnt0[i] = cnt0[i - 1] + (a[i] == 0); cnt1[i] = cnt1[i - 1] + (a[i] == 1); cnt2[i] = cnt2[i - 1] + (a[i] == 2); cnt3[i] = cnt3[i - 1] + (a[i] == 3); } while(q--){ int l = read(), r = read(); if(r - l + 1 &lt;= 4){ solve2(l, r); continue; } int A = cnt1[r] - cnt1[l - 1], B = cnt2[r] - cnt2[l - 1], C = cnt3[r] - cnt3[l - 1], D = cnt0[r] - cnt0[l - 1]; int cnt = 0; if(A) cnt++; if(B) cnt++; if(C) cnt++; if(cnt == 3){ puts(&quot;0&quot;); continue; } if(cnt == 2){ write(quickPower(2, D, mod)), endl; }else if(cnt == 1){ write((quickPower(2, D + 1, mod) - 1 + mod) % mod), endl; }else{ write((3 * quickPower(2, D, mod) - 3 + mod) % mod), endl; } } } signed main(){ int t = 1; while(t--) solve(); return 0; } ","tags":[],"title":"2024-10-21-solution-metahackercup2023round3C","feature":"","link":"https://WRuperD.github.io/post/2024-10-21-solution-metahackercup2023round3c/","stats":{"text":"4 min read","time":232000,"words":684,"minutes":4},"date":"2024-10-21 16:56:52","dateFormat":"2024-10-21"},{"abstract":"","content":"大牛逼题目。 牛逼的点在于这个如何判定环绕了岛屿一圈。题解给出了这样一种方式：考虑任意一个岛屿往下垂直的一条射线。如果你的路径从 (x,y)(x,y)(x,y) 经过了这个射线奇数次并回到了 (x,y)(x,y)(x,y) 那么你就一定包围了这个岛屿。 所以我们直接拆点，连边，边权为 u,vu,vu,v 和最近岛屿的距离的最小值，然后相当于一条最大边权最小的路径。这个直接 kruskal 重构树就做完了。 太牛逼了。代码写得一坨屎。 // Problem: Smooth Sailing (Hard Version) // URL: https://www.luogu.com.cn/problem/CF1920F2 // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 1e6 + 10; int n, m, q; vector &lt;char&gt; a[MAX]; vector &lt;int&gt; dis[MAX]; const int nxt[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; inline int To(int x, int y){ return (x - 1) * m + y; } struct node{ int u, v, w; }; node g[MAX * 5]; bool cmp(node x, node y){ return x.w &gt; y.w; } int psz; int fa[MAX * 4]; int val[MAX * 4]; int find(int x){ if(fa[x] == x) return x; return fa[x] = find(fa[x]); } vector &lt;int&gt; g2[MAX * 10]; int fat[MAX * 4], siz[MAX * 4], son[MAX * 4]; int dep[MAX * 4]; void dfs(int u){ siz[u] = 1; for(int v : g2[u]){ fat[v] = u, dep[v] = dep[u] + 1; dfs(v); siz[u] += siz[v]; if(siz[son[u]] &lt; siz[v]) son[u] = v; } } int top[MAX]; void dfs2(int u, int topu){ top[u] = topu; if(son[u]) dfs2(son[u], topu); for(int v : g2[u]){ if(v != son[u]) dfs2(v, v); } } int lca(int u, int v){ while(top[u] != top[v]){ if(dep[top[u]] &lt; dep[top[v]]) swap(u, v); u = fat[top[u]]; } return dep[u] &lt; dep[v] ? u : v; } void solve(){ n = read(), m = read(), q = read(); queue &lt;pair &lt;int, int&gt;&gt; que; pair &lt;int, int&gt; loww = make_pair(0, 0); for(int i = 1; i &lt;= n; i++){ a[i].pb('?'); dis[i].pb(0); for(int j = 1; j &lt;= m; j++){ char ch; cin &gt;&gt; ch; a[i].pb(ch); if(ch == 'v'){ dis[i].pb(0); que.push(make_pair(i, j)); }else{ dis[i].pb(inf); } if(ch == '#'){ loww = max(loww, make_pair(i, j)); } } } while(!que.empty()){ int x = que.front().first, y = que.front().second; que.pop(); for(int i = 0; i &lt; 4; i++){ int dx = x + nxt[i][0], dy = y + nxt[i][1]; if(dx &gt; n or dy &gt; m or !dx or !dy) continue; if(dis[dx][dy] &gt; dis[x][y] + 1){ dis[dx][dy] = dis[x][y] + 1; que.push(make_pair(dx, dy)); } } } // write(loww.first), put(), write(loww.second), endl; int m2 = 0; for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= m; j++){ if(a[i][j] == '#') continue; for(int k = 0; k &lt; 2; k++){ int dx = i + nxt[k][0], dy = j + nxt[k][1]; if(dx &gt; n or dy &gt; m or !dx or !dy or a[dx][dy] == '#') continue; g[++m2].u = To(i, j); g[m2].v = To(dx, dy); g[m2].w = min(dis[i][j], dis[dx][dy]); g[++m2].u = n * m + To(i, j); g[m2].v = n * m + To(dx, dy); g[m2].w = min(dis[i][j], dis[dx][dy]); } if(j == loww.second and i &gt;= loww.first){ for(int k = 2; k &lt; 4; k++){ int dx = i + nxt[k][0], dy = j + nxt[k][1]; if(dx &gt; n or dy &gt; m or !dx or !dy or a[dx][dy] == '#') continue; if(k == 2){ g[++m2].u = To(i, j); g[m2].v = n * m + To(dx, dy); g[m2].w = min(dis[i][j], dis[dx][dy]); g[++m2].u = n * m + To(i, j); g[m2].v = To(dx, dy); g[m2].w = min(dis[i][j], dis[dx][dy]); }else{ g[++m2].u = To(i, j); g[m2].v = To(dx, dy); g[m2].w = min(dis[i][j], dis[dx][dy]); g[++m2].u = n * m + To(i, j); g[m2].v = n * m + To(dx, dy); g[m2].w = min(dis[i][j], dis[dx][dy]); } } }else if(j == loww.second + 1 and i &gt;= loww.first){ for(int k = 2; k &lt; 4; k++){ int dx = i + nxt[k][0], dy = j + nxt[k][1]; if(dx &gt; n or dy &gt; m or !dx or !dy or a[dx][dy] == '#') continue; if(k == 3){ g[++m2].u = To(i, j); g[m2].v = n * m + To(dx, dy); g[m2].w = min(dis[i][j], dis[dx][dy]); g[++m2].u = n * m + To(i, j); g[m2].v = To(dx, dy); g[m2].w = min(dis[i][j], dis[dx][dy]); }else{ g[++m2].u = To(i, j); g[m2].v = To(dx, dy); g[m2].w = min(dis[i][j], dis[dx][dy]); g[++m2].u = n * m + To(i, j); g[m2].v = n * m + To(dx, dy); g[m2].w = min(dis[i][j], dis[dx][dy]); } } }else{ for(int k = 2; k &lt; 4; k++){ int dx = i + nxt[k][0], dy = j + nxt[k][1]; if(dx &gt; n or dy &gt; m or !dx or !dy or a[dx][dy] == '#') continue; g[++m2].u = To(i, j); g[m2].v = To(dx, dy); g[m2].w = min(dis[i][j], dis[dx][dy]); g[++m2].u = n * m + To(i, j); g[m2].v = n * m + To(dx, dy); g[m2].w = min(dis[i][j], dis[dx][dy]); } } } } sort(g + 1, g + m2 + 1, cmp); for(int i = 1; i &lt;= n * m * 2; i++) fa[i] = i; psz = n * m * 2; for(int i = 1; i &lt;= m2; i++){ if(find(g[i].u) == find(g[i].v)) continue; g2[++psz].pb(find(g[i].u)); g2[psz].pb(find(g[i].v)); fa[find(g[i].u)] = fa[find(g[i].v)] = psz; fa[psz] = psz; val[psz] = g[i].w; } int rt = find(1); dfs(rt); dfs2(rt, rt); while(q--){ int x = read(), y = read(); int ans = lca(To(x, y), To(x, y) + n * m); write(val[ans]), endl; } } signed main(){ int t = 1; while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"2024-10-21-solution-cf1920f2","feature":"","link":"https://WRuperD.github.io/post/2024-10-21-solution-cf1920f2/","stats":{"text":"8 min read","time":450000,"words":1271,"minutes":8},"date":"2024-10-21 16:48:04","dateFormat":"2024-10-21"},{"abstract":"","content":"学弟的 Div2 模拟赛 T4 题解 好题。 首先考虑怎么做到 O(nq)O(nq)O(nq)。要找到一种刻画方式来判断一组边是否使得给定点被染色。 我找到了这样一种方式：对于一条 xi&lt;xi+1x_i &lt; x_{i+1}xi​&lt;xi+1​ 的边，如果给定点在他的上方，那么将其权值设为 1。对于一条 xi&gt;xi+1x_i &gt; x_{i+1}xi​&gt;xi+1​ 的边，如果给定点在他的下方，那么将其权值设为 1。对于一条 xi=xi+1x_i = x_{i+1}xi​=xi+1​ 的边，这是细节，自己思考。当然如果在直线上那么权值也是 1。于是我们可以简单的发现有解当且仅当有两条对边权值均为 1。这样做显然是对的。 下面是一张题解中的图片。 这样你就会 O(nq)O(nq)O(nq) 了。由于是强制在线所以数据结构之类的基本就 GG 了。于是你考虑发掘更多的性质。如果你在调试的时候输出了答案序列 或者仔细思考有有惊人的注意力你就会发现所有的权值为 1 的边编号是连续的。仔细想想自证不难非常有道理。所以你的答案序列就非常好看了。 接下来讲讲我的蠢笨做法。 分类讨论，如果答案序列首尾不相同，那么直接二分就好了！ 如果首位相同，再 check⁡\\operatorname{check}check 一下 n/2+1n/2+1n/2+1 这个位置。如果和序列开头权值是相同的，那么如果全为 1 答案就是 Yes 否则就是 No（这个可以考虑存在答案长度）。如果不同的话，那么显然的就又变成了第一种情况，直接二分就好了！ 做完了，时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 一定一定要注意 xi=xi+1x_i = x_{i+1}xi​=xi+1​ 这部分的细节。 #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 1e5 + 10; struct node{ int x, y; }; node a[MAX]; const double eps = 1e-10; int n; bool check(int i, int x, int y){ int now = i, now2 = i + 1; if(i == n) now2 = 1; bool fl = 0; if(a[now].x &gt; a[now2].x){ fl = 1; }else if(a[now].x == a[now2].x){ int now3 = now - 1; if(now3 &lt; 1){ now3 = now2 + 1; fl = (a[now2].x &gt; a[now3].x); now = now2; now2 = now3; }else{ fl = (a[now3].x &gt; a[now].x); now2 = now; now = now3; } } double k = double(a[now].y - a[now2].y) / double(a[now].x - a[now2].x); double b = double(a[now].y) - k * double(a[now].x); if(abs(double(k) * x + b - y) &lt;= eps) return true; else if((double(k) * x + b &lt;= y) ^ fl) return true; else return false; } void solve(){ n = read(); for(int i = 1; i &lt;= n; i++){ a[i].x = read(), a[i].y = read(); } int q = read(); int pre = 0; while(q--){ int x = read(), y = read(); x = x ^ (pre * pre * pre); y = y ^ (pre * pre * pre); bool fl1 = check(1, x, y), fl2 = check(n, x, y); if(fl1 and !fl2){ int l = 1, r = n; int ans = 1; while(l &lt;= r){ int mid = (l + r) &gt;&gt; 1; if(check(mid, x, y)){ l = mid + 1; ans = mid; }else{ r = mid - 1; } } if(ans &gt; n / 2){ puts(&quot;Yes&quot;); pre++; }else{ puts(&quot;No&quot;); } }else if(!fl1 and fl2){ int l = 1, r = n; int ans = 1; while(l &lt;= r){ int mid = (l + r) &gt;&gt; 1; if(!check(mid, x, y)){ l = mid + 1; ans = mid; }else{ r = mid - 1; } } if(ans &lt; n / 2){ puts(&quot;Yes&quot;); pre++; }else{ puts(&quot;No&quot;); } }else{ bool fl3 = check(n / 2 + 1, x, y); if(fl3 == fl1){ if(fl1){ puts(&quot;Yes&quot;); pre++; }else{ puts(&quot;No&quot;); } }else{ int l = n / 2 + 1, r = n, ansr = n / 2 + 1; while(l &lt;= r){ int mid = (l + r) &gt;&gt; 1; if(check(mid, x, y) == fl3){ l = mid + 1, ansr = mid; }else{ r = mid - 1; } } l = 1, r = n / 2 + 1; int ansl = n / 2 + 1; while(l &lt;= r){ int mid = (l + r) &gt;&gt; 1; if(check(mid, x, y) == fl3){ ansl = mid; r = mid - 1; }else{ l = mid + 1; } } if(fl3){ if((ansr - ansl + 1) &gt; n / 2){ puts(&quot;Yes&quot;); pre++; }else{ puts(&quot;No&quot;); } }else{ if((ansr - ansl + 1) &lt; n / 2){ puts(&quot;Yes&quot;); pre++; }else{ puts(&quot;No&quot;); } } } } } } signed main(){ int t = 1; while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"2024-10-17-cspjplussimulation","feature":"","link":"https://WRuperD.github.io/post/2024-10-17-cspjplussimulation/","stats":{"text":"6 min read","time":326000,"words":1069,"minutes":6},"date":"2024-10-17 19:06:29","dateFormat":"2024-10-17"},{"abstract":"","content":"联考题目一道 题解 直接来吧！ 首先我们有式子 fi,j=min⁡(fi+1,j,ai+max⁡(fi+1,j−1,bi))f_{i,j} = \\min(f_{i+1,j},a_i+\\max(f_{i+1,j-1},b_i))fi,j​=min(fi+1,j​,ai​+max(fi+1,j−1​,bi​)) 其中 bib_ibi​ 递减。 设 ttt 表示最大的 jjj 使得 fi,j−1≤bif_{i,j-1} \\leq b_ifi,j−1​≤bi​。 当 j&lt;tj &lt; tj&lt;t 则 fi,j=min⁡(fi+1,j,ai+bi)fi,j=fi+1,j\\begin{aligned} f_{i,j} &amp;= \\min(f_{i+1,j},a_i+b_i) \\\\ f_{i,j} &amp;= f_{i+1,j} \\end{aligned} fi,j​fi,j​​=min(fi+1,j​,ai​+bi​)=fi+1,j​​ 非常好的性质。而且这个 bib_ibi​ 反过来 dp⁡\\operatorname{dp}dp 的话就是递增的，而 fi,j≥fi+1,jf_{i,j} \\geq f_{i+1,j}fi,j​≥fi+1,j​ 所以 ttt 也是递增的。 剩下部分的形式为 ： fi,j=min⁡(fi+1,j,ai+fi+1,j−1)f_{i,j} = \\min(f_{i+1,j},a_i+f_{i+1,j-1}) fi,j​=min(fi+1,j​,ai​+fi+1,j−1​) 这里为了形式同意不妨令 fi+1,t−1=bif_{i + 1,t-1} = b_ifi+1,t−1​=bi​。 然后就是这部分里面 fi,jf_{i,j}fi,j​ 显然是满足凸性的。所以考虑类似与 slope trick。维护上凸壳，凸壳上的每一个点为 (j,fi,j)(j,f_{i,j})(j,fi,j​)。那么我们找到第一个满足选择后面那个转移的点，相当于增加一条斜率为 aia_iai​ 的边，然后剩下部分整体平移。这可以直接优先队列做到。感觉非常非常的妙啊。 #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 5e3 + 10; struct node{ int a, b; }; node a[MAX]; bool cmp(node x, node y){ return x.b &gt; y.b; } int n; int f[MAX]; void solve(){ n = read(); for(int i = 1; i &lt;= n; i++){ a[i].a = read(), a[i].b = read(); } sort(a + 1, a + n + 1, cmp); for(int i = 1; i &lt;= n; i++) f[i] = inf; f[0] = 0; priority_queue &lt;int, vector &lt;int&gt;, greater&lt;int&gt;&gt; que; que.push(inf); int now = 0, t = 0; for(int i = n; i &gt;= 1; i--){ while(que.top() + now &lt;= a[i].b){ now = now + que.top(); que.pop(); f[++t] = now; } if(que.top() != inf){ int u = que.top(); que.pop(); que.push(u + now - a[i].b); } que.push(a[i].a), now = a[i].b; } while(t &lt; n){ now = now + que.top(); que.pop(); f[++t] = now; } for(int i = 1; i &lt;= n; i++){ write(f[i]), put(); }endl; } signed main(){ freopen(&quot;chef.in&quot;, &quot;r&quot;, stdin); freopen(&quot;chef.out&quot;, &quot;w&quot;, stdout); int t = 1; while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"2024-10-16-solution-noipsimulation","feature":"","link":"https://WRuperD.github.io/post/2024-10-16-solution-noipsimulation/","stats":{"text":"4 min read","time":227000,"words":690,"minutes":4},"date":"2024-10-16 19:48:28","dateFormat":"2024-10-16"},{"abstract":"","content":"The 3rd Universal Cup. Stage 1: St. Petersburg Problem A Element-Wise Comparison 题解 orz yhm. 记录一下这个 Trick。首先这个数据范围就很可以 bitset 乱搞。所以你考虑对于每个位置求出有哪些位置 aj&gt;aia_j &gt; a_iaj​&gt;ai​ 然后是一个区间异或。 有一个简单的方式是注意到如果 mmm 是固定的话，那么我们可以对序列分块，每 m,m,m, 个一组。这样子一个区间异或必定跨过1-2个区间。那么我们直接区间前后缀异或就行了。我觉得是很巧妙的。 #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 5e4 + 10; bitset &lt;MAX&gt; f[MAX], suf[MAX], nxt[MAX]; int a[MAX], pre[MAX]; void solve(){ int n = read(), m = read(); for(int i = 1; i &lt;= n; i++){ a[i] = read(); pre[a[i]] = i; } for(int i = n - 1; i &gt;= 1; i--){ f[pre[i]] = f[pre[i + 1]]; f[pre[i]][pre[i + 1] - 1] = 1; } // for(int i = 1; i &lt;= n; i++){ // for(int j = 0; j &lt; n; j++){ // write(f[i][j]), put(); // }endl; // } // endl; for(int i = 1; i &lt;= n; i++){ f[i] = (f[i] &gt;&gt; (i)); } // for(int i = 1; i &lt;= n; i++){ // for(int j = 0; j &lt; n; j++){ // write(f[i][j]), put(); // }endl; // } // endl; for(int i = 1; i &lt;= n; i++){ if(i % m == 0) suf[i] = f[i]; else suf[i] = (f[i] &amp; suf[i - 1]); } // 0111 // 1100 // 0011 // 1100 // 0001 for(int i = n; i &gt;= 1; i--){ if(i % m == 0) nxt[i] = f[i]; else nxt[i] = (f[i] &amp; nxt[i + 1]); } int ans = 0; for(int i = 1; i + m - 1 &lt;= n; i++){ ans += (nxt[i] &amp; suf[i + m - 1]).count(); } write(ans), endl; } signed main(){ int t = 1; while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"2024-10-16-solution-qoj8781","feature":"","link":"https://WRuperD.github.io/post/solution-qoj8781/","stats":{"text":"3 min read","time":157000,"words":477,"minutes":3},"date":"2024-10-16 19:16:58","dateFormat":"2024-10-16"},{"abstract":"","content":"是这样的，看个国足，看到了： ","tags":[{"name":"鲜花","slug":"tMU1QJpF3","used":true,"link":"https://WRuperD.github.io/tag/tMU1QJpF3/"}],"title":"2024-10-15 鲜花","feature":"","link":"https://WRuperD.github.io/post/2024-10-15-xian-hua/","stats":{"text":"1 min read","time":2000,"words":11,"minutes":1},"date":"2024-10-15 21:51:51","dateFormat":"2024-10-15"},{"abstract":"","content":"本题解同步发表于我的博客中 第一次场切 ARC E。提供一种简单思考角度的解法。 首先考虑 m−1m -1m−1 的答案推到 mmm 的答案。发现 Ansm=2Ansm−1+∑i=1m−1gcd⁡(ai,am)⋅2i−1Ans_{m} = 2Ans_{m-1}+ \\sum\\limits_{i=1}^{m-1} \\operatorname{gcd}(a_i,a_m) \\cdot 2^{i-1}Ansm​=2Ansm−1​+i=1∑m−1​gcd(ai​,am​)⋅2i−1。 观察到 O(nV)O(n\\sqrt V)O(nV​) 可过于是考虑枚举 ∑gcd⁡(ai,am)=xx⋅posx\\sum \\limits_{\\operatorname{gcd}(a_i, a_m) = x} x \\cdot pos_xgcd(ai​,am​)=x∑​x⋅posx​ 其中 posx=∑i=1m−1[gcd⁡(ai,am)=x]⋅ipos_x = \\sum \\limits_{i=1}^{m-1} [\\operatorname{gcd}(a_i,a_m) = x] \\cdot iposx​=i=1∑m−1​[gcd(ai​,am​)=x]⋅i。 但是发现你没办法快速确定 posxpos_xposx​ 的值。所以你考虑直接容斥。枚举 ama_mam​ 的因数 ddd。 ∑gcd⁡(ai,am)=xx⋅posx=∑d∣ai,d∣amwd⋅posd\\sum \\limits_{\\operatorname{gcd}(a_i, a_m) = x} x \\cdot pos_x = \\sum \\limits_{d| a_i, d | a_m} w_d \\cdot pos_d gcd(ai​,am​)=x∑​x⋅posx​=d∣ai​,d∣am​∑​wd​⋅posd​ 接下来考虑 wdw_dwd​ 的意义。发现如果 ddd 就是 gcd⁡(ai,am)\\operatorname{gcd}(a_i,a_m)gcd(ai​,am​) 的话那么所有 ddd 的因数的贡献都会再次被算一遍。所以可以简单的看出: wx=x−∑d∣xwdw_x = x - \\sum \\limits_{d|x} w_d wx​=x−d∣x∑​wd​ 预处理所有的 www 就做完了。 不是很懂为啥大家都是莫反做法。 // Problem: E - Adjacent GCD // URL: https://atcoder.jp/contests/arc185/tasks/arc185_e // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 5e5 + 10; const int MAX2 = 1e5 + 10; const int mod = 998244353; int a[MAX]; int w[MAX]; int cnt[MAX]; void solve(){ int n = read(); // write(w[2]), endl; for(int i = 1; i &lt;= n; i++){ a[i] = read(); } int preans = 0; int now = 1; for(int i = 1; i &lt;= n; i++){ preans = preans * 2 % mod; // write(preans), endl; for(int j = 1; j * j &lt;= a[i]; j++){ if(a[i] % j) continue; preans = (preans + w[j] * cnt[j] % mod) % mod; if(a[i] / j != j) preans = (preans + w[a[i] / j] * cnt[a[i] / j] % mod) % mod; } for(int j = 1; j * j &lt;= a[i]; j++){ if(a[i] % j) continue; cnt[j] = (cnt[j] + now) % mod; if(a[i] / j != j) cnt[a[i] / j] = (cnt[a[i] / j] + now) % mod; } write(preans), endl; now = now * 2 % mod; } } signed main(){ for(int i = 1; i &lt;= MAX2; i++){ w[i] = i; if(i == 1) continue; for(int j = 1; j * j &lt;= i; j++){ if(i % j) continue; w[i] = (w[i] + mod - w[j]) % mod; if(i / j != j and j &gt; 1) w[i] = (w[i] + mod - w[i / j]) % mod; } } int t = 1; while(t--) solve(); return 0; } ","tags":[],"title":"[ARC185E] Adjacent GCD 题解","feature":"https://WRuperD.github.io/post-images/arc185e-adjacent-gcd-ti-jie.gif","link":"https://WRuperD.github.io/post/arc185e-adjacent-gcd-ti-jie/","stats":{"text":"4 min read","time":224000,"words":670,"minutes":4},"date":"2024-10-15 16:04:23","dateFormat":"2024-10-15"},{"abstract":"","content":"记录一下这个牛逼的 Trick。已经是第二次在联考中见到了。 考虑如何刻画一个平面上的封闭图形的面积。考虑拆贡献，对于每条边（线段），我们可以算所有边与原点的叉积之和来求出总面积。 然而在网格图中，我们还有一个更加牛逼的刻画方式。即只算每条向左和向右边的贡献。不妨设整个图形在 xxx 轴上方，则我们可以用所有向右边的横坐标之和减去所有向左坐标的横坐标之和。 ","tags":[],"title":"2024-10-14-solution-模拟赛题一道","feature":"","link":"https://WRuperD.github.io/post/2024-10-14-solution-mo-ni-sai-ti-yi-dao/","stats":{"text":"1 min read","time":31000,"words":155,"minutes":1},"date":"2024-10-14 19:34:34","dateFormat":"2024-10-14"},{"abstract":"","content":"The 3rd Universal Cup. Stage 10: West Lake Problem C Permutation 题解 场上为队伍做出的唯一贡献。 考虑其实你直接每一个数去二分总次数是 nlog⁡n=10000n\\log n = 10000nlogn=10000 其实差的不是太多了。 我的想法是，但是感觉你每一个数每一个数的去做非常的亏。 然后每次你随机拉出两个数，两个一起做下去。你去暴力询问左边那个数的可能区间的左半边拼上右边那个数可能区间的右半边，如果这是询问为 222 或者 000 我们就省了一次操作。这很好，大致可以达到 34nlog⁡n{3\\over4}n \\log n43​nlogn 次操作。我以为如果你剪剪枝还是能过得。写出来寄了。 然后扔给 @yhddd 一看发现这样非常亏，你不如直接整体二分，然后你要是左半边填满了右边的数也就直接确定了。这样子做比较优秀，而且可以让你可以尽可能多的拉出两个数，尽管这东西理论上还是 34nlog⁡n{3\\over4}n \\log n43​nlogn 次操作的。这是可过的。尽管要是你随机多几次还是有可能超过次数限制。code。 其实正解也很简单，赛时也几乎想到了，但是没想到这样子做可以降低次数。就是你发现其实如果询问结果为 111 的话那么这两个数一定属于同一半边。所以你直接合并起来，继续操作。这样做就可以严格低于 666666666666 次操作了。代码没写。过了就行。 ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"2024-10-03-solution-ucup-season3-stage10-C","feature":"","link":"https://WRuperD.github.io/post/2024-10-03-solution-ucup-season3-stage10-c/","stats":{"text":"2 min read","time":90000,"words":415,"minutes":2},"date":"2024-10-03 19:27:12","dateFormat":"2024-10-03"},{"abstract":"","content":"[ARC122D] XOR Game 题解 弱智题，不知道怎么评的 *2300。 从高位往低位考虑，如果当前位数为 111 的个数为奇数，那么显然答案在这一位为 111。相当于求这一位为 111 和为 222 的数两两的最小异或值。使用 01 Tire 解决。 如果为偶数那么直接递归求解。 // Problem: [ARC122D] XOR Game // URL: https://www.luogu.com.cn/problem/AT_arc122_d // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 4e5 + 10; int to[MAX * 40][2]; int psz; int a[MAX]; void insert(int x){ int now = 0; for(int i = 31; i &gt;= 0; i--){ if(to[now][(((1ll &lt;&lt; i) &amp; x) != 0)] == -1){ to[now][(((1ll &lt;&lt; i) &amp; x) != 0)] = ++psz; now = psz; to[psz][0] = to[psz][1] = -1; }else{ now = to[now][(((1ll &lt;&lt; i) &amp; x) != 0)]; } } } int check(int x){ int now = 0, ans = 0; for(int i = 31; i &gt;= 0; i--){ if(to[now][(((1ll &lt;&lt; i) &amp; x) != 0)] == -1){ ans = ans + (1ll &lt;&lt; i); now = to[now][(((1ll &lt;&lt; i) &amp; x) == 0)]; }else{ now = to[now][(((1ll &lt;&lt; i) &amp; x) != 0)]; } } return ans; } int solve2(int l, int r, int x){ if(x &lt; 0) return 0; int mid = 0; for(int i = l; i &lt;= r; i++){ if(!(a[i] &amp; (1ll &lt;&lt; x))) mid = i; } if(!mid or mid == r){ return solve2(l, r, x - 1); } if((r - mid) % 2 == 0){ return max(solve2(l, mid, x - 1), solve2(mid + 1, r, x - 1)); } psz = 0; to[0][1] = to[0][0] = -1; for(int i = mid + 1; i &lt;= r; i++){ insert(a[i]); } int ans = inf; for(int i = l; i &lt;= mid; i++){ ans = min(ans, check(a[i])); } return ans; } void solve(){ int n = read(); for(int i = 1; i &lt;= 2 * n; i++){ a[i] = read(); } sort(a + 1, a + 2 * n + 1); write(solve2(1, 2 * n, 31)), endl;; } signed main(){ int t = 1; while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"2024-10-02-solution-arc122d","feature":"","link":"https://WRuperD.github.io/post/2024-10-02-solution-arc122d/","stats":{"text":"3 min read","time":170000,"words":492,"minutes":3},"date":"2024-10-02 19:26:44","dateFormat":"2024-10-02"},{"abstract":"","content":"[ARC121E] Directed Tree 题解 其实不太难的题目。 首先题目条件等价于 aia_iai​ 不能是 iii 的父亲。显然可以容斥，设 fi,jf_{i,j}fi,j​ 表示考虑到了节点 iii 钦定 jjj 个节点不满足条件。发现如果是考虑一个点往它向父亲的链选一个点这样算方案数非常没有前途。然后是一步高妙转换，考虑我们在 aia_iai​ 统计答案而不是在 iii。这样我们设 fu,if_{u,i}fu,i​ 表示 uuu 子树内 iii 个节点不满足条件。显然可以树形背包转移: fu,i⋅fv,j→fu,i+jf_{u,i} \\cdot f_{v,j} \\to f_{u,i+j} fu,i​⋅fv,j​→fu,i+j​ 注意这里 j&gt;0j &gt; 0j&gt;0。然后我们钦定 ai=ua_i = uai​=u 产生矛盾。 fu,i⋅(sizu−1−i)→fu,i+1f_{u,i} \\cdot (siz_u - 1 - i) \\to f_{u,i+1} fu,i​⋅(sizu​−1−i)→fu,i+1​ 复杂度是 O(n2)O(n^2)O(n2)。 // Problem: [ARC121E] Directed Tree // URL: https://www.luogu.com.cn/problem/AT_arc121_e // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 2e3 + 10; const int mod = 998244353; vector &lt;int&gt; g[MAX]; int siz[MAX]; int f[MAX][MAX]; int pre[MAX][MAX]; void dfs(int u){ siz[u] = 1; f[u][0] = pre[u][0] = 1; for(int v : g[u]){ dfs(v); for(int j = 0; j &lt;= siz[u]; j++){ for(int k = 1; k &lt;= siz[v]; k++){ pre[u][j + k] = (pre[u][j + k] + f[u][j] * f[v][k] % mod) % mod; } } siz[u] += siz[v]; for(int j = 0; j &lt;= siz[u]; j++) f[u][j] = pre[u][j]; } for(int i = siz[u]; i &gt;= 1; i--){ f[u][i] = (f[u][i] + f[u][i - 1] * (siz[u] - 1 - (i - 1)) % mod) % mod; } } int fac[MAX]; void solve(){ int n = read(); for(int i = 2; i &lt;= n; i++){ int u = read(); g[u].pb(i); } dfs(1); int pree = 1; fac[0] = 1; for(int i = 1; i &lt;= n; i++) fac[i] = fac[i - 1] * i % mod; int ans = 0; for(int i = 0; i &lt;= n; i++){ f[1][i] = f[1][i] * fac[n - i] % mod; if(i % 2 == 0) ans = (ans + f[1][i]) % mod; else ans = (mod + ans - f[1][i]) % mod; } write(ans), endl; } signed main(){ int t = 1; while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"2024-10-02-solution-arc121e","feature":"","link":"https://WRuperD.github.io/post/2024-10-02-solution-arc121e/","stats":{"text":"4 min read","time":197000,"words":596,"minutes":4},"date":"2024-10-02 19:26:20","dateFormat":"2024-10-02"},{"abstract":"","content":"[ARC121D] 1 or 2 题解 基本上会了。有趣的点在于转换。 首先你考虑每次只选 222 个糖的答案。这个是好猜的，是 max⁡ai−an−i+1−min⁡ai−an−i+1\\max a_i - a_{n-i+1} - \\min a_i - a_{n-i+1}maxai​−an−i+1​−minai​−an−i+1​。（ aia_iai​ 有序）。 但是可以每次只选一个唐。这个有点棘手。随机想一想，发现只选一个糖相当于选那个唐和一个美味值为 000 的。所以我们可以枚举加入多少个美味值为 000 的糖果。复杂度 O(n2log⁡n)O(n^2\\log n)O(n2logn)。 // Problem: [ARC121D] 1 or 2 // URL: https://www.luogu.com.cn/problem/AT_arc121_d // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 5e3 + 10; int a[MAX * 2]; int calc(int n){ int minn = inf, maxn = -inf; for(int i = 1; i &lt;= n / 2; i++){ minn = min(minn, a[i] + a[n - i + 1]); maxn = max(maxn, a[i] + a[n - i + 1]); } if(n % 2) minn = min(minn, a[n / 2 + 1]), maxn = max(maxn, a[n / 2 + 1]); return maxn - minn; } void solve(){ int n = read(); for(int i = 1; i &lt;= n; i++){ a[i] = read(); } sort(a + 1, a + n + 1); int ans = calc(n); for(int i = 1; i &lt;= n; i++){ sort(a + 1, a + n + i + 1); ans = min(ans, calc(n + i)); } write(ans), endl; } signed main(){ int t = 1; while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"2024-10-02-solution-arc121d","feature":"","link":"https://WRuperD.github.io/post/2024-10-02-solution-arc121d/","stats":{"text":"3 min read","time":134000,"words":407,"minutes":3},"date":"2024-10-02 19:25:55","dateFormat":"2024-10-02"},{"abstract":"","content":"[ARC122E] Increasing LCMs 题解 构造题都太神秘了，不看题解都不会做。bonus:抽时间阅读 https://www.luogu.com/article/o9mj50m1 考虑往一个已知序列里加入最后一个数 aia_iai​ 需要满足什么条件?发现有 \\operatorname{lcm} \\limits_j a_j &lt; \\operatorname{lcm} \\limits_{j \\ne i} a_j。 显然如果我们从最后一个数开始确定，那前面那个值是确定的。做完了。 当然直接算 lcm⁡\\operatorname{lcm}lcm 是非常蠢的。正确的做法是算 gcd⁡(aj,ai)\\operatorname{gcd} (a_j,a_i)gcd(aj​,ai​) 的 lcm⁡\\operatorname{lcm}lcm 与 aia_iai​ 的大小关系。 参考题解：link. // Problem: [ARC122E] Increasing LCMs // URL: https://www.luogu.com.cn/problem/AT_arc122_e // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int __int128 #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 105; int a[MAX]; int ret[MAX]; bool vis[MAX]; inline int lcm(int x, int y){ return x * y / __gcd(x, y); } void solve(){ int n = read(); for(int i = 1; i &lt;= n; i++){ a[i] = read(); } for(int i = n; i &gt;= 1; i--){ bool fl = 1; for(int j = 1; j &lt;= n; j++){ if(vis[j]) continue; int now = 1; for(int k = 1; k &lt;= n; k++){ if(vis[k] or k == j) continue; now = lcm(now, __gcd(a[k], a[j])); } if(now != a[j]){ vis[j] = 1; ret[i] = a[j]; fl = 0; break; } } if(fl){ puts(&quot;No&quot;); return ; } } puts(&quot;Yes&quot;); for(int i = 1; i &lt;= n; i++){ write(ret[i]), put(); } endl; } signed main(){ int t = 1; while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"solution-arc122e","feature":"","link":"https://WRuperD.github.io/post/solution-arc122e/","stats":{"text":"3 min read","time":137000,"words":417,"minutes":3},"date":"2024-10-01 19:25:01","dateFormat":"2024-10-01"},{"abstract":"","content":"[ARC111F] Do you like query problems? 题解 怎么拖到现在才写。 推式子题目。 首先套路的转为概率与期望，每一位的贡献显然是独立的，于是我们直接拆贡献。 首先来研究一下操作 1,21,21,2 对 aia_iai​ 的影响。手玩一下发现这相当于有 121\\over221​ 的概率 aia_iai​ 不变，121\\over221​ 的概率等概率变为 [1,m−1][1,m-1][1,m−1] 个数中的任意一个数字。这很好，我们可以将操作 1,21,21,2 一视同仁了。 于是我们可以直接算出 aia_iai​ 在 jjj 次操作后的期望数值。设其为 gi,jg_{i,j}gi,j​。那么有： gi,0=0gi,j=pi⋅2m2m+1⋅12⋅m−12+(1−pi⋅2m2m+1⋅12⋅m−12)gi,j−1gi,j=pim2m+1⋅m−12+(1−pim2m+1)gi,j−1\\begin{aligned} g_{i,0} &amp;= 0\\\\ g_{i,j} &amp;= p_i \\cdot {2m \\over {2m+1}} \\cdot {1\\over2} \\cdot {m-1 \\over 2} + (1-p_i \\cdot {2m \\over {2m+1}} \\cdot {1\\over2} \\cdot {m-1 \\over 2}) g_{i,j-1}\\\\ g_{i,j} &amp;= {p_i m \\over {2m+1}} \\cdot {m-1 \\over 2} + (1-{p_i m \\over {2m+1}}) g_{i,j-1} \\end{aligned} gi,0​gi,j​gi,j​​=0=pi​⋅2m+12m​⋅21​⋅2m−1​+(1−pi​⋅2m+12m​⋅21​⋅2m−1​)gi,j−1​=2m+1pi​m​⋅2m−1​+(1−2m+1pi​m​)gi,j−1​​ 显然有封闭形式。（自己做的时候就止步于此了。） 考虑设 hi=1−pim2m+1h_i = 1-{p_i m \\over {2m+1}}hi​=1−2m+1pi​m​ 则可以推出封闭形式： gi,j=12(m−1)(1−hij)g_{i,j} = {1\\over2}(m-1)(1-{h_i}^j) gi,j​=21​(m−1)(1−hi​j) 接着我们考虑算出 aia_iai​ 在一次操作中被选出来的概率，那么有 $$p_i = {2i(n-i+1)\\over n(n+1)}$$ 于是我们就可以列出最后的期望等于： ∑i=1npi2m+1∑j=0q−1gi,j=∑i=1npi2m+1⋅(m−1)2⋅(q−hiq−1hi−1)\\sum \\limits_{i=1} \\limits^{n} {p_i \\over 2m+1} \\sum \\limits_{j=0} \\limits^{q-1} g_{i,j} = \\sum \\limits_{i=1} \\limits^{n} {p_i \\over 2m+1} \\cdot {(m-1)\\over2} \\cdot(q-{h_i^q - 1 \\over h_i - 1}) i=1∑n​2m+1pi​​j=0∑q−1​gi,j​=i=1∑n​2m+1pi​​⋅2(m−1)​⋅(q−hi​−1hiq​−1​) 然后就推完了。 参考题解： link。 // Problem: [ARC111F] Do you like query problems? // URL: https://www.luogu.com.cn/problem/AT_arc111_f // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int mod = 998244353; int quickPower(int a,int b,int p){int base=a,ans=1;while(b){if(b&amp;1)ans*=base,ans%=p;base*=base;base%=p;b&gt;&gt;=1;}return ans;} void solve(){ int n = read(), m = read(), q = read(); int base = quickPower(n * (n + 1) / 2 % mod, mod - 2, mod); int base2 = quickPower((2 * m + 1) % mod, mod - 2, mod); int inv2 = quickPower(2, mod - 2, mod); int ans = 0; for(int i = 1; i &lt;= n; i++){ int px = i * (n - i + 1) % mod * base % mod; // write(px), endl; int now = px * base2 % mod * (m - 1) % mod * inv2 % mod; int now2 = q; int rx = (mod + 1 - px * m % mod * base2 % mod); now2 = (now2 + mod - (quickPower(rx, q, mod) - 1 + mod) % mod * quickPower((rx - 1 + mod) % mod, mod - 2, mod) % mod); now2 %= mod; now = now * now2 % mod; ans = (ans + now) % mod; } int tot = quickPower((n * (n + 1) / 2) % mod * (2 * m + 1) % mod, q, mod); ans = ans * tot % mod; write(ans), endl; } signed main(){ int t = 1; while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"2024-10-01-solution-arc111f","feature":"","link":"https://WRuperD.github.io/post/2024-10-01-solution-arc111f/","stats":{"text":"5 min read","time":274000,"words":833,"minutes":5},"date":"2024-10-01 19:24:32","dateFormat":"2024-10-01"},{"abstract":"","content":"题解：The 2019 ICPC Asia Nanjing Regional Contest，I. Space Station 模拟赛题目。 不难注意到 ai≤50a_i \\leq 50ai​≤50。所以事实上如果你不选 ai=0a_i=0ai​=0 的话只需要最多 505050 步就选完了。 所以考虑把所有 ai=0a_i=0ai​=0 的站点出去后（最后乘回来即可，对答案的贡献是固定的。）直接暴力搜索所有的状态。复杂度和 505050 的拆分数有关，所以不会太大。大概是在 5∗1055*10^55∗105 左右? 实现上的细节: 使用自然溢出可过。 建议用 unordered_map // Problem: I. Space Station // URL: https://codeforces.com/gym/103466/problem/I // Writer: WRuperD // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 1e6 + 10; #define ull unsigned long long const int base = 131, mod = 998244353; int a[MAX]; int pre[MAX]; int cnt[MAX]; unordered_map &lt;ull, int&gt; mp; inline int dfs(int x, int dep){ // write(x), put(), write(dep), endl; if(!dep) return 1; if(x &gt;= 50) return pre[dep]; int ans = 0; ull now = 0; for(int i = 1; i &lt;= 50; i++){ now = (now * (ull)base + (ull)cnt[i]); } if(mp.count(now)) return mp[now]; for(int i = 1; i &lt;= x; i++){ if(cnt[i]){ // puts(&quot;fk&quot;); cnt[i]--; ans = (ans + (cnt[i] + 1) * (dfs(x + i, dep - 1)) % mod) % mod; cnt[i]++; } } mp[now] = ans; return ans; } void solve(){ int n = read(); pre[0] = 1; for(int i = 1; i &lt;= n; i++) pre[i] = pre[i - 1] * i % mod; for(int i = 0; i &lt;= n; i++){ a[i] = read(); if(i) cnt[a[i]]++; } int ans = dfs(a[0], n - cnt[0]); // write(ans), endl; for(int i = n; i &gt;= n - cnt[0] + 1; i--) ans = ans * i % mod; write(ans), endl; } signed main(){ int t = 1; while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"solution-2019ICPCNanjing-Spacetation","feature":"","link":"https://WRuperD.github.io/post/solution-2019icpcnanjing-spacetationmd/","stats":{"text":"3 min read","time":156000,"words":470,"minutes":3},"date":"2024-10-01 19:23:34","dateFormat":"2024-10-01"},{"abstract":"","content":"爽。据说是本来每年我校有传统校领导要和（）的学生共进午餐。因为本来在学校饭堂太寒碜了，从去年开始就变成了组织学生免费去东莞美林湖温泉酒店度假。感恩。 考完二模之后立马就启动了。堵车 2.5。一直在打 phigros 自助晚餐本来想比大胃王比赛的，但是好像没什么好吃的，于是就自己吃撑了。晚上到房间已经 8：30 了，于是决定不去泡温泉了。实况足球启动！房间非常大。看着看着电视有人翻窗进来了。 本来打算11：00收手机后直接去棋牌室的，结果40才来收手机。。。。。 刷视频看到了这个 第二天早上吃早餐时突然听到有人说：“这是什么啊?&quot;一抬头看见所有校领导在看我打 phigros（（（（ 第二天还是被拉去打日本麻将了。一整天就胡了一把 /lh 中午金色大厅午餐， 不好吃。 还有 rr初见 希望学弟们明年都能来泡温泉。 什么，你问我 WHK？寄。 ","tags":[],"title":"5.25鲜花之美林湖之旅","feature":"","link":"https://WRuperD.github.io/post/525-xian-hua-zhi-mei-lin-hu-zhi-lu/","stats":{"text":"2 min read","time":60000,"words":293,"minutes":2},"date":"2024-05-26 14:16:07","dateFormat":"2024-05-26"},{"abstract":"","content":"2.22 被拉去打 div2 模拟赛，会并写了200pts，感觉非常良好。然后电脑就死机了，挂了 200 分 /fn /fn。 场切了T4，感觉还是非常自豪。 这是这场 T4 的solution。 2.26 div2 模拟赛，状态不是很好。mlk AK了。本来应该是会 200pts 的，但是最后 1h 开摆导致我没有想到 T2 的完全正解，只会 O(n2)O(n^2)O(n2)。挂了 40pts。 这是这场 T2 的solution 2.28 div2 模拟赛，状态不是很好。本来是 200 分薄纱全场的，但是输出格式错了，导致我 T1 挂了 95pts。 但是这几天虽然每场挂打分，但是稳定 rk3，怎么回事呢？ 这是这场 T1 的solution 今年第一次在 rating 上升期打 CCF 的比赛。感觉非常不错，既上了分，由攒够了 rp。 但是感觉最近心情不太好，总感觉这么打下去是在慢性死亡。我到底什么水平啊？ Drifting further everyday 2.29 打脸了，模拟赛爆蛋了。但是没关系。 晚上踢球居然提前被赶回来了 /fn /fn 3.1 试机，键盘不错，但是和 GDKOI 相比没了纸牌，差评。 到酒店。华莱士。看这就是中国。张维为。 22：30睡觉。 3.2 结束了，被 Day1T1 创爆了。T2 感觉大概会了，听 yinhee 讲的差不多，但是不会二分。 估分 0 + 0 + 0 躺在床上啥也不想干。结束了。 和 zzx 一起看非诚勿扰，难蚌。 zlt 大神 abc f 又拿首杀。 3.3 场上有点小摆，心态消极。感觉T1非常可做，是我不叫擅长的构造。很快就把直接构造扔了，考虑直接dp维护转移。很快想出怎么搞 O(2n)O(2^n)O(2n) 的状态。又瞪了1h发现自己貌似会了，但是对做法没啥信心。最后1.5h开始码码码码码。没写出来，寄。午饭时发现 yinhee 思路和我一模一样。输麻了。 估分 0 + 0 + 0 ","tags":[],"title":"Fade To Black - GDOI2024游记","feature":"","link":"https://WRuperD.github.io/post/fade-to-black-gdoi2024-you-ji/","stats":{"text":"2 min read","time":115000,"words":508,"minutes":2},"date":"2024-03-01 22:26:29","dateFormat":"2024-03-01"},{"abstract":"","content":"典但是好的构造题。（除了在卡空间和输出格式这两点上。） 观察一下发现每一个区间的答案只和其中的 0、1 数量奇偶有关。考虑当前区间推向下一个区间答案是怎么变化的，发现之和 i⊕i+ki \\oplus i + ki⊕i+k 有关。首先，如果 2∤n2 \\nmid n2∤n 那么显然无解。不然我们考虑构造出所有 iii 和 i+ki+ki+k 不相等那么就全对了。 考虑经典结论，iii 跳到 (i+k)mod n(i+k) \\mod n(i+k)modn 一定会形成若干个长度为 gcd⁡(n,k)\\gcd(n,k)gcd(n,k) 的环。如果环长为奇数（特殊性质）那直接染就完了。否则手玩一下，感觉让一个环最开始两个数重是很优的，要是这样然还不行，那就真无解了。 #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 8488609; bool a[MAX]; void solve(){ int n = read(), k = read(); if(n % 2) puts(&quot;-30&quot;), exit(0); int pre = 0; bool fl = 0; for(int i = 0; i &lt; __gcd(n, k); i++){ int now = i; bool cur = 1; while(1){ a[now] = cur; int to = (now + k) % n; if(to == i){ if(a[to] == (cur ^ 1)){ break; }else{ fl = 1; if(pre &lt;= 0){ pre++; break; }else{ pre--; a[to] ^= 1; break; } } if(a[to] != (cur ^ 1)){ puts(&quot;-30&quot;); return ; } break; }else{ now = to; cur ^= 1; } } } if(n == k or (n % 4 != 0 and k % 2 == 0)){ puts(&quot;-30&quot;); return ; } for(int i = 0; i &lt; n; i++) write(a[i]); endl; } signed main(){ int t = 1; while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"solution-contest2.28(div2)A","feature":"","link":"https://WRuperD.github.io/post/solution-contest228div2a/","stats":{"text":"3 min read","time":140000,"words":459,"minutes":3},"date":"2024-02-28 15:34:15","dateFormat":"2024-02-28"},{"abstract":"","content":"题面可以在 link 看到，但是貌似交不了？ 大力手玩题！场切了！ 首先看到这种题，我们一定是先想给定一个树怎么求他的最大独立集。我忘记怎么贪心了，于是考虑 DP,设 fu,0/1f_{u,0/1}fu,0/1​ 表示以 uuu 为根的子树中独立集包含或不包含 uuu 这个点的最大独立集大小。转移是显然的，为了下文讲解方便还是在这里写出： fu,0=∑v∈sonumax(fv,0,fv,1)fu,1=∑v∈sonufv,1\\begin{aligned} f_{u,0} &amp;= \\sum\\limits_{v\\in son_u}max(f_{v,0}, f_{v,1})\\\\ f_{u,1} &amp;= \\sum\\limits_{v\\in son_u}f_{v,1} \\end{aligned} fu,0​fu,1​​=v∈sonu​∑​max(fv,0​,fv,1​)=v∈sonu​∑​fv,1​​ 现在可以来考虑这道题了。考虑你把那么多的树接到同一个树上，这种题要么是矩阵快速幂维护转移，要么就是有点规律。显然的，通过上面的转移式可以看出一个点的答案只更他的儿子那一层有关系。这启发了我们只保留 T(i−1)T(i-1)T(i−1) 的根的那两个 dp 值，然后在每一个点加上相应的贡献。这样子做复杂度 O(n2)O(n^2)O(n2)，你就有了 60 分了！（这么水？） 下一步貌似没有头绪了。但是这时通过观察对拍的小数据的答案你惊讶地发现: Ansi=nAnsi−1+[unknown](Ans0)Ans_i= nAns_{i-1}+[unknown](Ans_0) Ansi​=nAnsi−1​+[unknown](Ans0​) 所以现在你需要解决的问题在于中间 +Ans0+Ans_0+Ans0​ 的条件是什么，然后你就可以愉快地 O(1)O(1)O(1) 递推了！ 首先你需要从本质上想想上面那玩意的正确性，如果答案是 nAnsi−1+Ans0nAns_{i-1} + Ans_0nAnsi−1​+Ans0​ 是非常符合常理的。原因是猜测原 dp 值加上某个值后大小关系不变，所以所有的转移是不变的，而每一个 fff 值初值一定被加上了 Ansi−1Ans_{i-1}Ansi−1​，所以就是 nAnsi−1+Ans0nAns_{i-1} + Ans_0nAnsi−1​+Ans0​。 细心的读者或许发现了上面那一段话的问题，就是不是所有的初值都被加上了 Ansi−1Ans_{i-1}Ansi−1​，如果设 Ansi,0/1Ans_{i,0/1}Ansi,0/1​ 表示选不选 kik_iki​ 作为根时候的答案，那么根据上面的定义, fff 的初值应当设为： fu,0=max(Ansi−1,0,Ansi−1,1)fu,1=Ansi−1,0+1\\begin{aligned} f_{u,0} &amp;= max(Ans_{i-1,0},Ans_{i-1,1})\\\\ f_{u,1} &amp;= Ans_{i-1,0} + 1 \\end{aligned} fu,0​fu,1​​=max(Ansi−1,0​,Ansi−1,1​)=Ansi−1,0​+1​ 如果 Ansi−1,0&lt;Ansi−1,1Ans_{i-1,0} &lt; Ans_{i-1,1}Ansi−1,0​&lt;Ansi−1,1​ 那么显然有的值相对于我们原来的估算就被少加了 Ansi−1,1−Ansi−1,0Ans_{i-1,1} - Ans_{i-1,0}Ansi−1,1​−Ansi−1,0​。而显然有一个结论是 Ansi−1,1−Ansi−1,0≤1Ans_{i-1,1} - Ans_{i-1,0} \\leq 1Ansi−1,1​−Ansi−1,0​≤1。所以贡献来攻先去毛估估一下刚好是少了 Ans0Ans_0Ans0​。 现在我们搞清楚了条件: Ansi=nAnsi−1+[Ansi−1,0≥Ansi−1,1](Ans0)Ans_i= nAns_{i-1}+[Ans_{i-1,0} \\geq Ans_{i-1,1}](Ans_0) Ansi​=nAnsi−1​+[Ansi−1,0​≥Ansi−1,1​](Ans0​) 所以我们现在需要弄明白的问题就只剩下了怎么样维护 Ansi,0,Ansi,1Ans_{i,0}, Ans_{i,1}Ansi,0​,Ansi,1​ 了。 再次观察一下答案的规律(什么鬼，居然是这么做的吗？)，发现貌似答案不大可能连续两次减少 Ans0Ans_0Ans0​。仔细想想，是因为你不可能连续两次不选根节点，不然可以调整成更优解？而 $0\\leq Ans_{i-1,1} - Ans_{i-1,0} \\leq 1 $，所以你考虑如果你 Ansi,0=Ansi,1Ans_{i,0} = Ans_{i,1}Ansi,0​=Ansi,1​，那么其实就是相当于在原树上直接做，然后答案加一个偏移量而已。这启发了你去考虑原树上的情况。所以结论就是如果在原树上以 uuu 为根做一遍 DP，这是如果什么 fi,0=fi,1f_{i,0} = f_{i,1}fi,0​=fi,1​,那么那个 Ans0Ans_0Ans0​ 的贡献是一定会加上去的。否则如果上一次加了贡献就不加了，否则不加 Ans0Ans_0Ans0​。然后你就做完了！ 非常厉害，好玩的题目。（我居然可以场切？） #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 1e5 + 10; const int mod = 998244353; vector &lt;int&gt; g[MAX]; int a[MAX]; int f[MAX][2]; int g2[MAX][2]; int g3[MAX][2]; bool fl[MAX]; void dfs(int u, int fa){ f[u][1] = 1, f[u][0] = 0; for(int v : g[u]){ if(v == fa) continue; dfs(v, u); f[u][0] += max(f[v][0], f[v][1]); f[u][1] += f[v][0]; } } void dfs3(int u, int fa){ for(int v : g[u]){ if(v == fa) continue; int tmpfk = f[u][1], tmpfk2 = f[u][0]; f[u][0] -= max(f[v][0], f[v][1]); f[u][1] -= f[v][0]; int tmp = f[v][0], tmp2 = f[v][1]; f[v][0] += max(f[u][0], f[u][1]); f[v][1] += f[u][0]; g2[v][0] = f[v][0], g2[v][1] = f[v][1]; dfs3(v, u); f[u][0] = tmpfk2, f[u][1] = tmpfk; f[v][0] = tmp, f[v][1] = tmp2; } } void solve(){ int n = read(), m = read(); for(int i = 1; i &lt; n; i++){ int u = read(), v = read(); g[u].pb(v), g[v].pb(u); } for(int i = 1; i &lt;= m; i++){ a[i] = read(); } dfs(1, 1); g2[1][1] = f[1][1], g2[1][0] = f[1][0]; dfs3(1, 1); write(max(f[1][1], f[1][0])), endl; int prert0 = f[1][0], prert1 = f[1][1]; int preans = max(f[1][1], f[1][0]); int tmp = preans; bool fl = g2[1][0] &lt; g2[1][1]; for(int i = 1; i &lt;= m; i++){ preans *= n; preans %= mod; preans += tmp; preans %= mod; if(fl) preans -= tmp; preans %= mod; if(preans &lt; 0) preans += mod; if(g2[a[i]][0] &lt; g2[a[i]][1]) fl ^= 1; else fl = 0; write(preans), endl; } } signed main(){ int t = 1; while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"2019CCPC-Wannafly Winter Camp Day3 (Div1, online mirror) solution-E最大独立集","feature":"","link":"https://WRuperD.github.io/post/2019ccpc-wannafly-winter-camp-day3-div1-online-mirror-solution-e-zui-da-du-li-ji/","stats":{"text":"8 min read","time":447000,"words":1538,"minutes":8},"date":"2024-02-22 16:39:07","dateFormat":"2024-02-22"},{"abstract":"","content":"打得依托答辩，写出了 tag[x] += tag[x&lt;&lt;1]; 状物 A 吃了一发罚时 /cf 感受一下，感觉只需要比较 ∑ai\\sum a_i∑ai​ 和 ∑bi\\sum b_i∑bi​ 的大小即可。 官方题解给出的证明是 x−y,y−xx-y,y-xx−y,y−x 相当于 x−min(x,y),y−min(x,y)x-min(x,y),y-min(x,y)x−min(x,y),y−min(x,y) 所以正确性显然。 B 由于是按位或操作，所以可以直接贪心。 C 显然有 fi=min(fi−1,max⁡j=1i−2[aj+1=ai](fj+i−j)f_i = min(f_{i-1}, \\max \\limits_{j=1}\\limits^{i - 2}[a_{j+1}=a_i](f_j+i-j)fi​=min(fi−1​,j=1maxi−2​[aj+1​=ai​](fj​+i−j)。 所以把每个不同的 aia_iai​ 的最大的 fff 值记录下来简单处理即可。 code D 上难度了。挺不错的一题。 首先观察样例，手玩一下，发现答案的上界显然是从 nnn 到 111 的最短路。原因显然。考虑怎么构造，如果你手玩的足够仔细，你就会发现他大概是怎么样才会不选某一个点。发现其实你只有当一条只有一边有点被选的边选的次数顶满了才会舍掉那个点、边。于是我们考虑按照所有点与 nnn 点的距离排序。从当前方案中每次删掉当前距离最近的所有点。这样做正确性还是相当显然。 code E 赛时居然没调出来。 首先有一个很强的性质可以通过观察得到，就是选的所有三角形一定不交。 注意到 k≤105k \\leq 10^5k≤105，提醒我们或许可以考虑设 fif_ifi​ 表示前 iii 行被覆盖完的最小代价。发现由于三角形不交，所以我们当前一定是这样子放三角形： 所以转移只需要枚举当前三角形的上角顶在了哪一行即可。 先考虑不放三角形的转移，非常好转移，把代价拆开直接转移即可，但我还是写了直接线段树优化。 然后考虑不放三角形的转移。发现每个区间要加上的代价不一样，拆不来。貌似没思路了？事实上，n≤105n \\leq 10^5n≤105，所以你直接在线段树上区间加即可！ code F 好题！ 考虑题目中带有绝对值，直接做貌似不太好消掉这个绝对值。 人类智慧的一步是钦定所有黑点的重心为根。回顾重心定义，发现删掉重心之后的最大连通块大小 ≤n2\\leq {n\\over2}≤2n​。于是我们成功去掉了绝对值。考虑怎么放黑点才可以是的答案最小。拆一下贡献，发现每一个黑点会产生到根的距离乘二的负贡献。按距离根节点记录排序即可。 code G 参见 link H 感觉 1 不好看，所以不妨使 xxx 在 [−0.5,0.5][-0.5,0.5][−0.5,0.5] 范围内随机。这样所有的限制都变成了相加小于或大于等于零。 注意到对于 x+y≤0x+y \\leq0x+y≤0 而言，若 ∣x∣≥∣y∣|x| \\geq |y|∣x∣≥∣y∣ 则相当于 x≤0x \\leq 0x≤0。所以我们只需要关注每个值的绝对值大小关系即可。直接暴力状压 DP 暴力检查计入一个数是否合法复杂度 O(2nn2)O(2^n n^2)O(2nn2)，稍微预处理一下即可变为 O(2nn)O(2^nn)O(2nn) code ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"},{"name":"学习笔记","slug":"qWhunhKoya","used":true,"link":"https://WRuperD.github.io/tag/qWhunhKoya/"}],"title":"【VP记录】CodeTON Round 5 (Div. 1 + Div. 2) A ~ H 题解","feature":"","link":"https://WRuperD.github.io/post/vp-ji-lu-codeton-round-5-div-1-div-2-a-~-h-ti-jie/","stats":{"text":"4 min read","time":210000,"words":891,"minutes":4},"date":"2024-02-21 19:35:23","dateFormat":"2024-02-21"},{"abstract":"","content":"一道没有那么难但是我还是不会(甚至一开始就想歪了)的计数题。 考虑逆序操作，在一个全零的序列中选择一个数加 kkk 或连续 kkk 个数加一。显然这种计数题关键在于如何去重。我们考虑使得每一种最终序列对应唯一的操作序列。发现如果你对于一个长度为 kkk 的区间进行了 kkk 次区间加一和你对于其中每一个数分别单点 +k+k+k 是等价的。考虑设 bib_ibi​ 表示在 [i,i+k−1][i,i+k-1][i,i+k−1] 操作区间加一的操作次数，则我们可以钦定所有 ∀i∈[1,n−k+1],bi&lt;k\\forall i \\in [1,n-k+1],b_i &lt; k∀i∈[1,n−k+1],bi​&lt;k。当然还有单点加，我们设 bn−k+1+ib_{n-k+1+i}bn−k+1+i​ 表示在位置 iii 进行单点加的操作次数。最后我们只需要对满足条件的不同 bbb 序列进行简单计数即可。综上，bbb 序列应满足以下条件： ∀i∈[1,n−k+1],bi&lt;k\\forall i \\in [1,n-k+1],b_i &lt; k∀i∈[1,n−k+1],bi​&lt;k。 ∑i=1nbi=mk\\sum\\limits_{i=1}\\limits^{n}b_i = {m\\over k}i=1∑n​bi​=km​ 计数是简单的，容斥一下，钦定有 iii 位不满足条件，相当于先钦定 iii 位放有 kkk 个操作，然后将剩下 mk−ik{m\\over k} - ikkm​−ik 个操作分给 2n−k2n-k2n−k 个位置，插板法，则有： ans=∑i=0i=n−k+1(−1)i(n−k+1i)(mk−ik+2n−k2n−k)ans = \\sum\\limits_{i=0}\\limits^{i=n-k+1} (-1)^{i} {n - k + 1 \\choose i} {{m\\over k} - ik + 2n-k \\choose 2n-k} ans=i=0∑i=n−k+1​(−1)i(in−k+1​)(2n−kkm​−ik+2n−k​) code ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"solution-arc160d","feature":"","link":"https://WRuperD.github.io/post/solution-arc160d/","stats":{"text":"3 min read","time":120000,"words":448,"minutes":3},"date":"2024-02-20 19:12:39","dateFormat":"2024-02-20"},{"abstract":"","content":"orz zjk。学到了。对于这一类计数最终由多少不同局面的题，我们首先应当考虑一下如何判断最终局面合法。感觉正着做不太方便，于是我们考虑倒着做。 首先，容易发现 0 和 1 是对称的，哪个是 0 哪个是 1 不重要，所以我们不妨设 A≤BA \\leq BA≤B。 考虑倒着操作是怎么样的，于是我们将操作改写为： 选择 xxx 中长度为 AAA 的字串，其中字符为 0 或 ?，将他们改为 ?。 选择 xxx 中长度为 BBB 的字串，其中字符为 1 或 ?，将他们改为 ?。 容易发现，我们只要最后到达了全是 0 或者 ? 的字符串就有解了。观察并手玩一下，发现只要进行了一次二操作，就一定有解。原因是进行一次二操作后我们可以得到一个长度为 BBB 的 ? 区间。我们必定可以通过每次往左，往右拓展一格使得整个字符串被置为 ?。 到这里有解的限制就变得清晰了。一个最终局面 xxx 有解当且仅当将其长度大于等于 AAA 的字串置为 1之后，1 的极长连续段的长度大于等于 BBB。 现在你可以直接计数了。这部分是简单的。 code ","tags":[],"title":"solution-agc045c","feature":"","link":"https://WRuperD.github.io/post/solution-agc045c/","stats":{"text":"2 min read","time":73000,"words":345,"minutes":2},"date":"2024-02-19 09:53:37","dateFormat":"2024-02-19"},{"abstract":"","content":"见过相同 Trick 之后貌似也不是太难？ 相似题：CF838D 套路的，算期望乘以总方案数。计算期望是简单的，是所有逆序对产生的概率相加。算概率是简单的，直接 DP 即可。 code ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"solution-agc030d","feature":"","link":"https://WRuperD.github.io/post/solution-agc030d/","stats":{"text":"1 min read","time":13000,"words":64,"minutes":1},"date":"2024-02-18 15:29:42","dateFormat":"2024-02-18"},{"abstract":"","content":"Galaxy Online Judge: The world's slowest online judge UOJ ","tags":[],"title":"每日情绪输出","feature":"","link":"https://WRuperD.github.io/post/mei-ri-qing-xu-shu-chu/","stats":{"text":"1 min read","time":3000,"words":10,"minutes":1},"date":"2024-02-02 15:24:31","dateFormat":"2024-02-02"},{"abstract":"","content":"前言 今天早上 div2 模拟赛的最后一道题。本来想着早点 AK 走了，没想到看到了这道名字叫做的题目。一打开一股浓浓的 ARC 大分讨的感觉瞬间溢出屏幕。 题解 字典序，首先我们要意识到所有的 B 要尽量在前面，而且 B 要尽量少删。然后我们开始大力手玩、分讨。 S 的末尾为A 对于这种情况，我们可以做到不删 B。我们考虑每次选择一个极长的 A 的连续段的段首与 S 的末尾。这样子我们发现只要这个连续段的长度大于等于二那么 S 的末尾还是 A，且其它 A 都被仍到末尾了。对于所有 A 的长度为 1 的连续段我们可以两个两个和起来删。这样子做容易发现就是最优的了。设 A 长度大于 1 的连续段个数为 xxx，长度为一的连续段个数为 yyy 那么有操作次数为 x+⌈y2⌉x + \\lceil {y \\over 2} \\rceilx+⌈2y​⌉。 S 的末尾不为A 先考虑一些不用删 B 的情况。 S 中 A 的个数为偶数 把 A 全部删掉！显然这样子是最大的了。 S 中 A全部都在开头 没得玩了，把 A 尽可能删掉吧！ S 中最后一个 A 在 n−1n - 1n−1 或 n−2n - 2n−2 位。 首先前面已经考虑的 A 的个数为偶数的情况了。所以我们可以把除了那个 A 之外的 A 全部删光。经过一点思考发现这样子是最优的。 好吧，现在我们貌似必须要开始删 B 了。 考虑删一个 A 连续段之前的一个 B 和末尾的那个 B 会发生什么，发现变成了 S 的末尾为 A 的情况了！怎么删最优？显然我们挪一个长度大于等于 2 的 A 连续段到末尾最好了。如此操作，我们就在最多删两个 B 的情况下严格的做完了这道题。 code ","tags":[],"title":"solution-arc113e","feature":"","link":"https://WRuperD.github.io/post/solution-arc113e/","stats":{"text":"2 min read","time":116000,"words":531,"minutes":2},"date":"2024-01-30 16:30:04","dateFormat":"2024-01-30"},{"abstract":"","content":"开坑。 ARC 158 finished on 2024.1.26 [ARC158D] Equation 不好玩的随机化题。有一说一第一次见这么随机的。 考虑设左边柿子为 F(x,y,z)F(x,y,z)F(x,y,z) 右边为 G(x,y,z)G(x,y,z)G(x,y,z) ，考虑你直接去随机一组 (x,y,z)(x,y,z)(x,y,z)，此时设 F(x,y,z)=tG(x,yz)F(x,y,z) = tG(x,yz)F(x,y,z)=tG(x,yz) 则有 F(xt,yt,zt)=G(xt,yt,zt)F({x\\over t},{y\\over t},{z\\over t}) = G({x\\over t},{y\\over t},{z\\over t})F(tx​,ty​,tz​)=G(tx​,ty​,tz​)。在模意义下这都很好算。但是可能会有一些情况是 G=0G = 0G=0 或者 x,y,zx,y,zx,y,z 有相同的数。继续随机即可。 [ARC158E] All Pair Shortest Paths https://wruperd.github.io/post/solution-arc158e/ *2600 还是挺牛逼的一题。但是为什么其他题解都说很板？看来还是我太菜了，见的题太少了。 主要参考 @TeneryTree 首先考虑 CDQ 分治，只考虑处理 [l,mid][l,mid][l,mid] 中的到 [mid+1,r][mid+1,r][mid+1,r] 这些点的路径和。 由于列数 m=2m=2m=2 所以我们考虑设 fi,0/1f_{i,0/1}fi,0/1​ 为左边的点 (i,0/1)(i,0/1)(i,0/1) 到 (mid,0)(mid,0)(mid,0) 的最短路距离，右边的点 (i,0/1)(i,0/1)(i,0/1) 到 (mid+1,0)(mid+1,0)(mid+1,0) 的最短路距离。设 gi,0/1g_{i,0/1}gi,0/1​ 为左边的点 (i,0/1)(i,0/1)(i,0/1) 到 (mid,1)(mid,1)(mid,1) 的最短路距离，右边的点 (i,0/1)(i,0/1)(i,0/1) 到 (mid+1,1)(mid+1,1)(mid+1,1) 的最短路距离。显然这两玩意每次直接 O(n)O(n)O(n) 递推即可。 然后考虑一下跨区间的贡献是什么。设贡献为 www 则有： w=2∑i=lmid∑j=mid+1rmin⁡(fi,0/1+fj,0/1,gi,0/1+gj,0/1)w = 2\\sum\\limits_{i=l}\\limits^{mid}\\sum\\limits_{j=mid+1}\\limits^{r} \\min ( f_{i,0/1} + f_{j,0/1},g_{i,0/1} + g_{j,0/1}) w=2i=l∑mid​j=mid+1∑r​min(fi,0/1​+fj,0/1​,gi,0/1​+gj,0/1​) 这玩意看着好像不太好直接计算。也不太知道怎么想到的，考虑这样子做： w=2∑i=lmid∑j=mid+1r{min⁡(fi,0/1+fj,0/1−gi,0/1−gj,0/1,0)+gi,0/1+gj,0/1}w = 2\\sum\\limits_{i=l}\\limits^{mid}\\sum\\limits_{j=mid+1}\\limits^{r} \\{ \\min ( f_{i,0/1} + f_{j,0/1} - g_{i,0/1}- g_{j,0/1},0) + g_{i,0/1} + g_{j,0/1} \\} w=2i=l∑mid​j=mid+1∑r​{min(fi,0/1​+fj,0/1​−gi,0/1​−gj,0/1​,0)+gi,0/1​+gj,0/1​} 然后拎出去! w=2∑i=lmid∑j=mid+1r{min⁡(fi,0/1+fj,0/1−gi,0/1−gj,0/1,0)}+4∑i=lmidgi,0/1⋅(r−mid)+4∑i=mid+1rgi,0/1⋅(mid−l+1)w = 2\\sum\\limits_{i=l}\\limits^{mid}\\sum\\limits_{j=mid+1}\\limits^{r} \\{ \\min ( f_{i,0/1} + f_{j,0/1} - g_{i,0/1}- g_{j,0/1},0)\\} + 4\\sum\\limits_{i=l}\\limits^{mid}g_{i,0/1}\\cdot(r-mid) + 4\\sum\\limits_{i=mid+1}\\limits^{r}g_{i,0/1}\\cdot(mid-l+1) w=2i=l∑mid​j=mid+1∑r​{min(fi,0/1​+fj,0/1​−gi,0/1​−gj,0/1​,0)}+4i=l∑mid​gi,0/1​⋅(r−mid)+4i=mid+1∑r​gi,0/1​⋅(mid−l+1) 现在这个式子好看多了qwq。后面那一整串直接计算即可了。而前面那一串取值也只有两种情况，非常好搞。设前面那一串值为 2w22w_22w2​，一下省略 0/1 这一维。设 pi=fi−gip_i = f_i - g_ipi​=fi​−gi​ 则有： w2=∑i=lmid∑j=mid+1rmin⁡(pi+pj,0)w_2 = \\sum\\limits_{i=l}\\limits^{mid}\\sum\\limits_{j=mid+1}\\limits^{r} \\min (p_i+p_j,0) w2​=i=l∑mid​j=mid+1∑r​min(pi​+pj​,0) =∑i=lmid∑j=mid+1r(pi+pj)[pi&gt;−pj]= \\sum\\limits_{i=l}\\limits^{mid}\\sum\\limits_{j=mid+1}\\limits^{r}(p_i+p_j)[p_i&gt;-p_j] =i=l∑mid​j=mid+1∑r​(pi​+pj​)[pi​&gt;−pj​] 这玩意相当好弄，只需要排序二分一下做完了。 总的复杂度 O(nlog⁡2n)O(n\\log^2n)O(nlog2n) code Some more experiences P7482 不条理狂诗曲 ARC157 [ARC157D] YY Garden haven't written yet [ARC157E] XXYX Binary Tree 虚高 *2800，如果放模拟赛的话人均场切了。 首先，这题的关键点这是一颗 二叉树 洛谷没有翻译出来。 读一下题目容易发现有一个不存在父亲和儿子同时是 Y 这个很强的限制。这启发了我们去看有关于 Y 的限制。发现给你了个什么 YX 的数量，这是什么？这个显然是非叶子节点的 Y 的数量的两倍。再看 XY 的数量是什么，这个也显然是非根节点 Y 的数量的两倍。知道了这些性质，再分类讨论一下根节点是否是 Y 你就知道了叶子节点上 Y 的个数了！ 现在整道题的限制只剩下两个了,一个是在非叶子节点放置 Y 的数量和在叶子节点放置 Y 的数量。由于这题只是让你验证是否有解而非计数，所以你设 fu,j,0/1f_{u,j,0/1}fu,j,0/1​ 表示在节点 uuu 子树中选了 jjj 个叶子为 Y,有没有选择当前节点时最多选择多少个非叶子节点放 Y。直接转移即可。 时间复杂度 O(n2)O(n^2)O(n2) code ARC156 finished on 2024.1.29 [ARC156C] Tree and LCS 不好玩的构造题。zlt没场切，不写题解了。 https://atcoder.jp/contests/arc156/submissions/49684957 [ARC156D] Xor Sum 5 *2500 参考https://www.luogu.com.cn/blog/CFA-44/solution-at-arc156-d 众所周知的是，异或两次等于没有。 考虑对于每一个序列找出双射，发现对于一个序列 AAA 如果它不是一个回文序列则一定可以将他反过来，设其为 A′A&#x27;A′,则 A⊕A′=0A \\oplus A&#x27; =0A⊕A′=0，且 AAA 与 A′A&#x27;A′ 构成双射。因此，我们只需要统计所有为回文序列的 AAA。 设 fif_ifi​ 为长度为 iii 的所有 AAA 的异或和。 对于一个偶回文序列，显然有 f2i=2fif_{2i} = 2f_if2i​=2fi​，但是对于一个奇回文序列就不太好搞了。考虑加一维，设 fi,jf_{i,j}fi,j​ 表示所有长度为 iii 序列 AAA 的 j+∑k=1iaAij + \\sum\\limits_{k=1}\\limits^{i}a_{A_i}j+k=1∑i​aAi​​ 的值异或和。现在感觉可以做了一点。 对于偶回文串：f2i,j=2fi,⌊j2⌋+[njmod 2=0]f_{2i,j} = 2f_{i,\\lfloor{j\\over2}\\rfloor}+[nj \\mod2=0]f2i,j​=2fi,⌊2j​⌋​+[njmod2=0]。[njmod 2=0][nj \\mod2=0][njmod2=0] 的意义留给读者自行思考。 对于奇回文串，我们枚举中间那个数是什么，然后递归至偶回文串情况： f2i,j=⨁k=1n2fi,⌊(j+ak)2⌋+[n(j+ak)mod 2=0]f_{2i,j} = \\bigoplus\\limits_{k=1}\\limits^{n} 2f_{i,\\lfloor{(j+a_k)\\over2}\\rfloor}+[n(j+a_k) \\mod2=0]f2i,j​=k=1⨁n​2fi,⌊2(j+ak​)​⌋​+[n(j+ak​)mod2=0]。 特判一下 i=1i=1i=1 的情况。 code ARC155 最自闭的一集。 ARC154 finished on 2024.1.29 [ARC154D] A + B &gt; C ? 只有一道，没想到吧!/cf 非常简单的一题，但是我又玩泥巴了。直接考虑排序，显然最多有 nlog⁡nn\\log nnlogn 次比较，可以过。怎么比较两个数的大小？先用 n−1n-1n−1 次问出 1 在哪里即可。 懒得写排序？stable_sort。 code ARC113 [ARC113E] Rvom and Rsrev link 模拟赛题，大力分讨即可？具体看上面 link。 code ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"},{"name":"学习笔记","slug":"qWhunhKoya","used":true,"link":"https://WRuperD.github.io/tag/qWhunhKoya/"}],"title":"ARC *2000~*2800 乱做","feature":"","link":"https://WRuperD.github.io/post/arc-2000~2800-luan-zuo/","stats":{"text":"9 min read","time":527000,"words":1852,"minutes":9},"date":"2024-01-28 20:28:28","dateFormat":"2024-01-28"},{"abstract":"","content":"我是 GDFZ 初三菜鸡oier。 luogu,codeforces,Atcoder,loj,AcWing同名。 关于本博客 由于洛谷社区被搞没了，cnblogs年久失修。于是便启用了这个博客。（2024.1.27） 文章都是本人十分 Naive 的见解，请见谅。可以当我在说废话。 以前文章不代表本人现在观点，以前的定义是这个时刻之前（确信 ","tags":[{"name":"个人介绍","slug":"Kxw-KxcFW","used":true,"link":"https://WRuperD.github.io/tag/Kxw-KxcFW/"}],"title":"关于我","feature":"","link":"https://WRuperD.github.io/post/about/","stats":{"text":"1 min read","time":21000,"words":98,"minutes":1},"date":"2024-01-27 19:01:35","dateFormat":"2024-01-27"},{"abstract":"","content":"题目链接：https://codeforces.com/problemset/problem/1142/E *3500 基本上复读其他题解？因为不知道怎么想到的。 首先考虑只有绿的边的情况。 竞赛图有一些很好的性质link。 根据上面链接中的定理1，我们考虑将最终的竞赛图强连通缩点。由于拓扑序小的点对于每一个拓扑序大的点都有连边，我们考虑一种做法：维护一个当前可能成为最后答案的集合 SSS。每次从 SSS 中取出两点，询问他们的边的指向，将被指向的点删除。 考虑这种做法的正确性。首先最后 SSS 中剩下的那一个点一定是拓扑序最小的强连通分量中的一点。这可以由定理1得到。比方说，对于每一条边 u→vu \\to vu→v,如果 uuu 和 vvv 是属于同一个强连通分量，那么显然这么取可以让 uuu 和 vvv 联通。这样取下去每一个连通块内都会被缩成强连通分量。我们可以任意保留 uuu 或者 vvv，于是这部分就是对的。如果 uuu 和 vvv 不属于同一个强连通分量，那么有拓扑序小的强连通块连向拓扑序大的连通块。所以我们保留 uuu 就是一定对的。 接下来考虑粉色边的情况。这种情况下，如果我们再钦定答案为全集，这时候我们不能询问粉色的边，就会出现问题。从特殊情况入手，假设粉色边构成了一张有向无环图，那么非常好办，我们可以臆想我们从所有入度为零的点开始按照拓扑序的顺序进行了若干次询问，然后所有粉色边就没了。剩下的情况就是有粉色边构成了若干强连通分量。这时候考虑缩点，把所有强连通分量缩成一个点。考虑什么情况下才会询问到粉色的边，发现其实你只需要保证在同一个强连通分量内的点不同时出现在 SSS 中即可。所以我们选一个点代表一个联通块，当一个强连通分量中的那个点被删去后，我们再把其中任意一个其它的点放入 SSS 中即可。 这样子做由于每次都会删掉一个点，所以最多 n−1n - 1n−1 次询问。 实现上不用很麻烦，其实只需要删去一些能让粉色边构成环的粉边即可。 code 感谢 @gdf_yhm 教我做题。 最后，请容许我在这里致敬一下伟大的摇滚乐队 Pink Floyd。啥都不说了 ，平克·佛洛依德牛皮！ ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"Pink Floyd","feature":"","link":"https://WRuperD.github.io/post/pink-floyd/","stats":{"text":"3 min read","time":147000,"words":706,"minutes":3},"date":"2024-01-25 23:21:53","dateFormat":"2024-01-25"},{"abstract":"","content":"平凡的，如果 S1S_1S1​ 没有构成一个外向树森林，那么无解。 否则，如果 S1S_1S1​ 构成了一个个外向树，那么我们考虑将他们的顶点相连、合并。如果不行则无解。 怎么搞?直接暴力枚举当前外向及外向树顶点与其他外向树是否有可以连的边。并查集启发式合并即可。 时间复杂度不是 O(N+M+K)O(N+M+K)O(N+M+K)，还要加一个什么并查集的 log⁡\\loglog 为什么是对的？ 考虑你会写出如下代码 for(auto v3 : st[find(v)]){ if(!mp[u].count(v3)){ v2 = v3; break; } } 你一共只会有 kkk 次继续枚举。 code 如果是这种做法的话，那这道题可以算非常小清新了。 感谢hzx。 来点后记。 比赛时我在想什么？我想到了这个均摊 O(k)O(k)O(k) 的玩意。 但是补题补sb了，想到 Pink Floyd 去了。 所以写题不要上头!!!! 这道题提醒了我们一些补图上走边走点的算法或许可以均摊? ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"eert","feature":"","link":"https://WRuperD.github.io/post/eert/","stats":{"text":"2 min read","time":62000,"words":277,"minutes":2},"date":"2024-01-25 23:21:22","dateFormat":"2024-01-25"},{"abstract":"","content":"一道非常有意思的题。 考虑构造出一堆环，使得每次大操作后每个环内数都沿着环走一步。 这样子最后重新回到初始状态的步数是所有环长的最小公倍数。 先来钦定一下环长，考虑 k=∏picik = \\prod p_i^{c_i}k=∏pici​​，那我们不加证明地猜测最优方案时环长 leni=picilen_i = p_i^{c_i}leni​=pici​​。 考虑一个类似于 S 形填数。 如图，这是这个图中存在的最大的一个可能的环。 接着，我们把这个环分成若干段。 如图是在 k=60k=60k=60 时的一种划分方式。接下来我们只需要找到一种构造方式使得每一此只交换边上的两个点就做完了。 下面是其中一种方案： 至此，我们做完了整道题。 点击查看代码 // Problem: P7372 [COCI2018-2019#4] Slagalica // Contest: Luogu // URL: https://www.luogu.com.cn/problem/P7372 // Memory Limit: 64 MB // Time Limit: 1000 ms // // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 1e2 + 10; struct node{ int x, y, op; }; vector &lt;node&gt; ans; void up1(int x, int y){ ans.pb(node{x, y, 2}); ans.pb(node{x, y, 2}); ans.pb(node{x, y, 1}); // puts(&quot;u1&quot;); // write(x), put(), write(y), endl; } void up2(int x, int y){ ans.pb(node{x, y, 1}); ans.pb(node{x, y, 2}); ans.pb(node{x, y, 1}); ans.pb(node{x, y, 1}); // puts(&quot;u2&quot;); // write(x), put(), write(y), endl; } void across2(int x, int y){ ans.pb(node{x, y, 1}); ans.pb(node{x, y, 2}); ans.pb(node{x, y, 2}); // puts(&quot;a1&quot;); // write(x), put(), write(y), endl; } void across1(int x, int y){ ans.pb(node{x, y, 1}); ans.pb(node{x, y, 1}); ans.pb(node{x, y, 2}); ans.pb(node{x, y, 1}); // puts(&quot;a2&quot;); // write(x), put(), write(y), endl; } int n, m, k; int nowx = 1, nowy = 1; int id[MAX][MAX]; bool tonxt(){ if(nowx % 2) nowy++; else nowy--; if(nowy &lt;= 0) nowx++, nowy = 1; if(nowy &gt; m) nowy = m, nowx++; if(nowx &gt; n) return false; return true; } void work(int x){ // write(x), endl; if(nowx &gt; n){ puts(&quot;-1&quot;); exit(0); } x--; int prex = nowx, prey = nowy; while(x--){ if(!tonxt()){ puts(&quot;-1&quot;); exit(0); } if(prex == nowx){ if(prex == n){ across2(prex, min(prey, nowy)); }else{ across1(prex + 1, min(prey, nowy)); } }else{ if(nowy == m){ up1(nowx, m - 1); }else{ up2(nowx, 1); } } prex = nowx, prey = nowy; } tonxt(); // endl; } void solve(){ n = read(), m = read(), k = read(); int psz = 0; for(int i = 2; i * i &lt;= k; i++){ int cnt = 1; while(k % i == 0){ cnt *= i; k /= i; } if(cnt &gt; 1) work(cnt); } if(k &gt; 1) work(k); write(ans.size()), endl; for(int i = 0; i &lt; ans.size(); i++){ putchar(ans[i].op == 1 ? 'R' : 'T'), put(); write(ans[i].x - 1), put(), write(ans[i].y), endl; } } signed main(){ int t = 1; while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"solution-p7372","feature":"","link":"https://WRuperD.github.io/post/solution-p7372/","stats":{"text":"4 min read","time":234000,"words":722,"minutes":4},"date":"2024-01-25 23:20:48","dateFormat":"2024-01-25"},{"abstract":"","content":"sto nantf orz 正文 算得上相当有意思以及启发性的数据结构题了。 三进制表示联想到我们可以建立一个三叉树。类似于 Trie 一样的，按三进制从低位到高位建立一个 Trie 树。一个非常好的性质这是一个完美三叉树。 接下来我们可以考虑怎么维护每一种操作。 Salasa 舞 对于这种操作，相当于对于树上每一个点都交换他们的 1,2 两个儿子。打个标记即可支持。 Rumba 舞 这相当于什么呢？我们发现，相当于把原来的 0 号儿子给到 1 号儿子，把原来的 1 号儿子给到 2 号儿子，把原来的 2 号儿子给到 0 号儿子。前两者没有进位，所以不用管，发现原来 2 号儿子会产生一个进位操作。这相当于什么呢？这相当于在这个儿子子树内再进行一次 Rumba 舞操作。递归求解即可。 总复杂度 O(3n+Tn)O(3^n+Tn)O(3n+Tn) code ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"solution-at-agc044-c","feature":"","link":"https://WRuperD.github.io/post/solution-at-agc044-c/","stats":{"text":"2 min read","time":60000,"words":277,"minutes":2},"date":"2024-01-25 23:20:22","dateFormat":"2024-01-25"},{"abstract":"","content":"The 2nd Universal Cup. Stage 16: Run Twice-Mark on a Graph link 最搞笑的一集。 搞笑解法 蚌埠住了。由于oj肯定是连续测你的程序并跑两遍，于是便有了一个搞笑的做法：判断程序开始时time(0)的奇偶性，然后sleep到下一秒再结束。这样子你就有50%的概率通过此题。 #import&lt;time.h&gt; main(){int t=time(0);puts(t&amp;1?&quot;mark 0&quot;:&quot;ok&quot;);while(t==time(0));} 这样你就在一条边都不动的情况下过了这道题。 从信息论的角度上来讲，这是图灵奖级别的。 一个简单但是不知道正确性的解法 找到原图中度数最大的 5 个点，将他们用五次操作连成一个环。在新图中他们也是度数最大的 5 个点。这样我们就可以辨别是否是我们操作过的图。 感性理解一下，度数最大5个点被随机连在一起的概率不是很大？ 一个官方解法 考虑在原图整出一个5阶无向完全图K5。显然的，自然随机生成出k5的概率非常低。我们在原图中随机搞5个点，直到他们之间原本有5个边，然后我们把它加成k5弄回去。这样我们就做到了辨认。 如何在图中找到k5？考虑你直接在每个点爆搜，剪一下枝，复杂度是 E(K1)+E(K2)+E(K3)+E(K4)+E(K5)E(K1)+E(K2)+E(K3)+E(K4)+E(K5)E(K1)+E(K2)+E(K3)+E(K4)+E(K5) 的，毛估估一下在合理范围内。 ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"solution-The 2nd Universal Cup. Stage 16: Run Twice-Mark on a Graph","feature":"","link":"https://WRuperD.github.io/post/solution-the-2nd-universal-cup-stage-16-run-twice-mark-on-a-graph/","stats":{"text":"2 min read","time":96000,"words":413,"minutes":2},"date":"2024-01-25 23:19:24","dateFormat":"2024-01-25"},{"abstract":"","content":"[ARC158E] All Pair Shortest Paths 还是挺牛逼的一题。但是为什么其他题解都说很板？看来还是我太菜了，见的题太少了。 主要参考 @TeneryTree 首先考虑 CDQ 分治，只考虑处理 [l,mid][l,mid][l,mid] 中的到 [mid+1,r][mid+1,r][mid+1,r] 这些点的路径和。 由于列数 m=2m=2m=2 所以我们考虑设 fi,0/1f_{i,0/1}fi,0/1​ 为左边的点 (i,0/1)(i,0/1)(i,0/1) 到 (mid,0)(mid,0)(mid,0) 的最短路距离，右边的点 (i,0/1)(i,0/1)(i,0/1) 到 (mid+1,0)(mid+1,0)(mid+1,0) 的最短路距离。设 gi,0/1g_{i,0/1}gi,0/1​ 为左边的点 (i,0/1)(i,0/1)(i,0/1) 到 (mid,1)(mid,1)(mid,1) 的最短路距离，右边的点 (i,0/1)(i,0/1)(i,0/1) 到 (mid+1,1)(mid+1,1)(mid+1,1) 的最短路距离。显然这两玩意每次直接 O(n)O(n)O(n) 递推即可。 然后考虑一下跨区间的贡献是什么。设贡献为 www 则有： w=2∑i=lmid∑j=mid+1rmin⁡(fi,0/1+fj,0/1,gi,0/1+gj,0/1)w = 2\\sum\\limits_{i=l}\\limits^{mid}\\sum\\limits_{j=mid+1}\\limits^{r} \\min ( f_{i,0/1} + f_{j,0/1},g_{i,0/1} + g_{j,0/1}) w=2i=l∑mid​j=mid+1∑r​min(fi,0/1​+fj,0/1​,gi,0/1​+gj,0/1​) 这玩意看着好像不太好直接计算。也不太知道怎么想到的，考虑这样子做： w=2∑i=lmid∑j=mid+1r{min⁡(fi,0/1+fj,0/1−gi,0/1−gj,0/1,0)+gi,0/1+gj,0/1}w = 2\\sum\\limits_{i=l}\\limits^{mid}\\sum\\limits_{j=mid+1}\\limits^{r} \\{ \\min ( f_{i,0/1} + f_{j,0/1} - g_{i,0/1}- g_{j,0/1},0) + g_{i,0/1} + g_{j,0/1} \\} w=2i=l∑mid​j=mid+1∑r​{min(fi,0/1​+fj,0/1​−gi,0/1​−gj,0/1​,0)+gi,0/1​+gj,0/1​} 然后拎出去! w=2∑i=lmid∑j=mid+1r{min⁡(fi,0/1+fj,0/1−gi,0/1−gj,0/1,0)}+4∑i=lmidgi,0/1⋅(r−mid)+4∑i=mid+1rgi,0/1⋅(mid−l+1)w = 2\\sum\\limits_{i=l}\\limits^{mid}\\sum\\limits_{j=mid+1}\\limits^{r} \\{ \\min ( f_{i,0/1} + f_{j,0/1} - g_{i,0/1}- g_{j,0/1},0)\\} + 4\\sum\\limits_{i=l}\\limits^{mid}g_{i,0/1}\\cdot(r-mid) + 4\\sum\\limits_{i=mid+1}\\limits^{r}g_{i,0/1}\\cdot(mid-l+1) w=2i=l∑mid​j=mid+1∑r​{min(fi,0/1​+fj,0/1​−gi,0/1​−gj,0/1​,0)}+4i=l∑mid​gi,0/1​⋅(r−mid)+4i=mid+1∑r​gi,0/1​⋅(mid−l+1) 现在这个式子好看多了qwq。后面那一整串直接计算即可了。而前面那一串取值也只有两种情况，非常好搞。设前面那一串值为 2w22w_22w2​，一下省略 0/1 这一维。设 pi=fi−gip_i = f_i - g_ipi​=fi​−gi​ 则有： w2=∑i=lmid∑j=mid+1rmin⁡(pi+pj,0)w_2 = \\sum\\limits_{i=l}\\limits^{mid}\\sum\\limits_{j=mid+1}\\limits^{r} \\min (p_i+p_j,0) w2​=i=l∑mid​j=mid+1∑r​min(pi​+pj​,0) =∑i=lmid∑j=mid+1r(pi+pj)[pi&gt;−pj]= \\sum\\limits_{i=l}\\limits^{mid}\\sum\\limits_{j=mid+1}\\limits^{r}(p_i+p_j)[p_i&gt;-p_j] =i=l∑mid​j=mid+1∑r​(pi​+pj​)[pi​&gt;−pj​] 这玩意相当好弄，只需要排序二分一下做完了。 总的复杂度 O(nlog⁡2n)O(n\\log^2n)O(nlog2n) code ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"solution-arc158e","feature":"","link":"https://WRuperD.github.io/post/solution-arc158e/","stats":{"text":"5 min read","time":251000,"words":797,"minutes":5},"date":"2024-01-25 23:18:28","dateFormat":"2024-01-25"},{"abstract":"","content":"定义式 E(x)=∑iP(x=i)∗iE(x) = \\sum \\limits_{i}P(x=i)*iE(x)=i∑​P(x=i)∗i 即随机变量 xxx 结果为 iii 的概率乘上结果。 拆开来 E(x)=∑i&gt;0P(x=i)∗i+∑i&lt;0P(x=i)∗iE(x) = \\sum \\limits_{i&gt;0}P(x=i)*i + \\sum \\limits_{i&lt;0}P(x=i)*iE(x)=i&gt;0∑​P(x=i)∗i+i&lt;0∑​P(x=i)∗i 只看前一部分，E(x)=∑i≥0P(x=i)∗iE(x) = \\sum \\limits_{i\\geq0}P(x=i)*iE(x)=i≥0∑​P(x=i)∗i。 将 iii 看成若干个 PiP_iPi​ 相加。 得到 E(x)=∑i=1∞∑j=i∞P(x=j)E(x) = \\sum\\limits_{i=1}\\limits^{\\infty}\\sum \\limits_{j=i}\\limits^{\\infty}P(x=j)E(x)=i=1∑∞​j=i∑∞​P(x=j) 单独看 ∑j=i∞P(x=j)\\sum \\limits_{j=i}\\limits^{\\infty}P(x=j)j=i∑∞​P(x=j) 这部分。这相当于 P(x≥i)P(x\\geq i)P(x≥i). 至此，于是我们得到了一个相当好看的式子： E(x)=∑i≥0P(x&gt;i)−∑i≤0P(x&lt;i)E(x) = \\sum \\limits_{i \\geq 0}P(x &gt; i) - \\sum\\limits_{i \\leq 0}P(x&lt;i)E(x)=i≥0∑​P(x&gt;i)−i≤0∑​P(x&lt;i) 这也就是7月份集训时zz大佬课件里面我一直搞不懂的东西。 期望具有线性性 E(ax+by)=aE(x)+bE(y)E(ax+by) = aE(x)+bE(y)E(ax+by)=aE(x)+bE(y) PiP_iPi​ ","tags":[{"name":"学习笔记","slug":"qWhunhKoya","used":true,"link":"https://WRuperD.github.io/tag/qWhunhKoya/"}],"title":"期望小柿子","feature":"","link":"https://WRuperD.github.io/post/qi-wang-xiao-shi-zi/","stats":{"text":"2 min read","time":104000,"words":324,"minutes":2},"date":"2024-01-20 19:05:32","dateFormat":"2024-01-20"},{"abstract":"","content":"纪念一下自己在UOJ上通过的第一道除了 A+B problem 和 Quine 之外的题。 题目链接 不对啊，这道也是 A+B problem 正文 看到什么黑白染色，分别得到代价，容易想到最小割。 建图是长这样的： 对于每一个点 iii 我们连边 (s,i,bi),(i,t,wi)(s,i,b_i), (i,t,w_i)(s,i,bi​),(i,t,wi​).考虑那个什么奇怪的点的限制，对于每一个点建一个虚点 iii 然后对于所有满足条件的 jjj 连边 (i′,j,inf)(i&#x27;,j,inf)(i′,j,inf).这样连边正确性显然。 BTW,如果限制是方格 jjj 是白色怎么做啊?/yun 求教。 优化 这道题图比较复杂，貌似不能模拟网络流？（谁会能不能教教我啊qwq） 由于上面的边数是 n2n^2n2 的，完全跑不了，所以考虑优化建图，减少边数。考虑一个点是向一个区间进行连边，那么显然直接线段树优化建图即可。这里可能需要用到主席树，原因是需要 nnn 个版本的树的节点。边数降到了 nlog⁡nn \\log nnlogn 点击查看代码 // Problem: #77. A+B Problem // Contest: UOJ // URL: https://uoj.ac/problem/77 // Memory Limit: 48 MB // Time Limit: 2000 ms // // Powered by CP Editor (https://cpeditor.org) #include&lt;bits/stdc++.h&gt; using namespace std; const long long inf = 1e18; const int mininf = 1e9 + 7; #define int long long #define pb emplace_back inline int read(){int x=0,f=1;char ch=getchar();while(ch&lt;'0'||ch&gt;'9'){if(ch=='-')f=-1;ch=getchar();}while(ch&gt;='0'&amp;&amp;ch&lt;='9'){x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);ch=getchar();}return x*f;} inline void write(int x){if(x&lt;0){x=~(x-1);putchar('-');}if(x&gt;9)write(x/10);putchar(x%10+'0');} #define put() putchar(' ') #define endl puts(&quot;&quot;) const int MAX = 1e5 + 10; int psz = 2; struct flow{ struct node{ int v, w, cp; }; vector &lt;node&gt; g[MAX]; int dis[MAX]; bool bfs(int s, int t){ for(int i = 1; i &lt;= psz; i++) dis[i] = mininf; dis[s] = 0; queue &lt;int&gt; q; q.push(s); while(!q.empty()){ int u = q.front(); q.pop(); for(auto V : g[u]){ if(V.w &gt; 0 and dis[V.v] &gt; dis[u] + 1){ dis[V.v] = dis[u] + 1; q.push(V.v); } } } if(dis[t] == mininf) return 0; return 1; } int cur[MAX]; int aug(int u, int now, int t){ if(u == t) return now; int ans = 0; for(int &amp;i = cur[u]; i &lt; g[u].size(); i++){ int v = g[u][i].v, w = g[u][i].w, cp = g[u][i].cp; if(dis[v] != dis[u] + 1) continue; int ret = aug(v, min(w, now), t); g[u][i].w -= ret, g[v][cp].w += ret; now -= ret, ans += ret; if(now &lt;= 0) break; } return ans; } void add_edge(int u, int v, int w){ g[u].pb(node{v, w, g[v].size()}); g[v].pb(node{u, 0, g[u].size() - 1}); } }; flow g; int a[MAX], b[MAX], w[MAX], l[MAX], r[MAX], p1[MAX]; int p[MAX], p2[MAX]; int lsh[MAX]; int rt[MAX]; int s[MAX &lt;&lt; 5], ls[MAX &lt;&lt; 5], rs[MAX &lt;&lt; 5]; void pushup(int x){ s[x] = s[ls[x]] + s[rs[x]]; } void upd(int l, int r, int pos, int prex, int val, int &amp;x){ if(!x) x = ++psz; s[x] = s[prex], ls[x] = ls[prex], rs[x] = rs[prex]; if(l == r){ s[x]++; g.add_edge(x, p[val], inf); g.add_edge(x, prex, inf); return ; } int mid = (l + r) &gt;&gt; 1; if(pos &lt;= mid) ls[x] = 0; else rs[x] = 0; if(pos &lt;= mid) upd(l, mid, pos, ls[prex], val, ls[x]); else upd(mid + 1, r, pos, rs[prex], val, rs[x]); if(ls[x]) g.add_edge(x, ls[x], inf); if(rs[x]) g.add_edge(x, rs[x], inf); pushup(x); } void query(int l, int r, int dl, int dr, int val, int &amp;x){ if(!x) return ; if(dl &lt;= l and r &lt;= dr){ g.add_edge(p2[val], x, inf); return ; } int mid = (l + r) &gt;&gt; 1; if(dl &lt;= mid) query(l, mid, dl, dr, val, ls[x]); if(dr &gt; mid) query(mid + 1, r, dl, dr, val, rs[x]); } void solve(){ int n = read(); int s = 1, t = 2; int ans = 0; for(int i = 1; i &lt;= n; i++){ a[i] = read(), b[i] = read(), w[i] = read(), l[i] = read(), r[i] = read(), p1[i] = read(); p[i] = ++psz, p2[i] = ++psz; ans += b[i] + w[i]; g.add_edge(s, p[i], b[i]), g.add_edge(p[i], t, w[i]); g.add_edge(p[i], p2[i], p1[i]); lsh[i] = a[i]; } sort(lsh + 1, lsh + n + 1); int n2 = unique(lsh + 1, lsh + n + 1) - lsh - 1; for(int i = 1; i &lt;= n; i++){ a[i] = lower_bound(lsh + 1, lsh + n2 + 1, a[i]) - lsh; l[i] = lower_bound(lsh + 1, lsh + n2 + 1, l[i]) - lsh; r[i] = upper_bound(lsh + 1, lsh + n2 + 1, r[i]) - lsh - 1; } for(int i = 1; i &lt;= n; i++){ if(r[i] &gt;= l[i]) query(1, n2, l[i], r[i], i, rt[i - 1]); rt[i] = 0; upd(1, n2, a[i], rt[i - 1], i, rt[i]); } while(g.bfs(s, t)){ for(int i = 1; i &lt;= psz; i++) g.cur[i] = 0; ans -= g.aug(s, inf, t); } write(ans), endl; } signed main(){ int t = 1; while(t--) solve(); return 0; } ","tags":[{"name":"题解","slug":"WOwIZ3qJn","used":true,"link":"https://WRuperD.github.io/tag/WOwIZ3qJn/"}],"title":"UOJ#77 A+B Problem","feature":"","link":"https://WRuperD.github.io/post/uoj77-ab-problem/","stats":{"text":"7 min read","time":362000,"words":1084,"minutes":7},"date":"2024-01-15 23:22:33","dateFormat":"2024-01-15"},{"abstract":"","content":"备忘录 数数题 int preasd[MAX]; int inv123[MAX]; int F114[MAX]; int quickPower(int a,int b,int p){int base=a,ans=1;while(b){if(b&amp;1)ans*=base,ans%=p;base*=base;base%=p;b&gt;&gt;=1;}return ans;} int c2(int n, int m){ if(m &gt; n) return 0; return preasd[n] * F114[m] % mod * F114[n-m] % mod; } signed main(){ preasd[0] = F114[0] = 1; preasd[1] = inv123[1] = F114[1] = 1; for(int i = 2; i &lt; MAX; i++){ preasd[i] = 1ll * preasd[i - 1] * i % mod; inv123[i] = 1ll * inv123[mod % i] * (mod - mod / i) % mod; F114[i] = 1ll * F114[i - 1] * inv123[i] % mod; } } 网络流 int psz = 2; struct flow{ struct node{ int v, w, cp; }; vector &lt;node&gt; g[MAX]; int dis[MAX]; bool bfs(int s, int t){ for(int i = 1; i &lt;= psz; i++) dis[i] = mininf; dis[s] = 0; queue &lt;int&gt; q; q.push(s); while(!q.empty()){ int u = q.front(); q.pop(); for(auto V : g[u]){ if(V.w &gt; 0 and dis[V.v] &gt; dis[u] + 1){ dis[V.v] = dis[u] + 1; q.push(V.v); } } } if(dis[t] == mininf) return 0; return 1; } int cur[MAX]; int aug(int u, int now, int t){ if(u == t) return now; int ans = 0; for(int &amp;i = cur[u]; i &lt; g[u].size(); i++){ int v = g[u][i].v, w = g[u][i].w, cp = g[u][i].cp; if(dis[v] != dis[u] + 1) continue; int ret = aug(v, min(w, now), t); g[u][i].w -= ret, g[v][cp].w += ret; now -= ret, ans += ret; if(now &lt;= 0) break; } return ans; } void add_edge(int u, int v, int w){ g[u].pb(node{v, w, g[v].size()}); g[v].pb(node{u, 0, g[u].size() - 1}); } }; struct min_max_flow{ int cur[MAX], dis[MAX]; int vis[MAX]; struct Edge{ int v, w, c, cp; }; vector &lt;Edge&gt; g[MAX]; void add_edge(int u, int v, int w, int c){ Edge e1 = Edge{v, w, c, g[v].size()}; Edge e2 = Edge{u, 0, -c, g[u].size()}; g[u].push_back(e1); g[v].push_back(e2); } bool bfs(int s, int t) { queue&lt;int&gt; q; for(int i = 0; i &lt;= psz; i++){ dis[i] = inf; } memset(vis, 0, sizeof(vis)); vis[s] = true; dis[s] = 0; q.push(s); while(!q.empty()){ int u = q.front(); q.pop(); vis[u] = false; int l = g[u].size(); for(int i = 0; i &lt; l; i++) { int v = g[u][i].v, r = g[u][i].w, c = g[u][i].c; if(r and dis[u] + c &lt; dis[v]){ dis[v] = dis[u] + c; if(!vis[v]){ vis[v] = true; q.push(v); } } } } return dis[t] != inf; } int aug(int u, int l, int &amp;cost, int t){ if(u == t) return l; vis[u] = true; int f = 0; for(int &amp;i = cur[u]; i &lt; g[u].size(); i++){ int v = g[u][i].v, r = g[u][i].w, c = g[u][i].c; if(dis[v] != dis[u] + c or !r or vis[v]) continue; int d = aug(v, min(r, l), cost, t); g[u][i].w -= d; g[v][g[u][i].cp].w += d; f += d, l -= d; cost += d*c; if(!l) break; } vis[u] = false; return f; } }; 3*3矩阵 struct Matrix{ int n = 3, m = 3; long long a[3][3]; Matrix operator *(const Matrix &amp;x) const{ Matrix c; c.a[0][0] = a[0][0] * x.a[0][0] + a[0][1] * x.a[1][0] + a[0][2] * x.a[2][0]; c.a[0][1] = a[0][0] * x.a[0][1] + a[0][1] * x.a[1][1] + a[0][2] * x.a[2][1]; c.a[0][2] = a[0][0] * x.a[0][2] + a[0][1] * x.a[1][2] + a[0][2] * x.a[2][2]; c.a[1][0] = a[1][0] * x.a[0][0] + a[1][1] * x.a[1][0] + a[1][2] * x.a[2][0]; c.a[1][1] = a[1][0] * x.a[0][1] + a[1][1] * x.a[1][1] + a[1][2] * x.a[2][1]; c.a[1][2] = a[1][0] * x.a[0][2] + a[1][1] * x.a[1][2] + a[1][2] * x.a[2][2]; c.a[2][0] = a[2][0] * x.a[0][0] + a[2][1] * x.a[1][0] + a[2][2] * x.a[2][0]; c.a[2][1] = a[2][0] * x.a[0][1] + a[2][1] * x.a[1][1] + a[2][2] * x.a[2][1]; c.a[2][2] = a[2][0] * x.a[0][2] + a[2][1] * x.a[1][2] + a[2][2] * x.a[2][2]; return c; } Matrix operator +(const Matrix &amp;x) const{ Matrix c; c.clear2(); c.a[0][0] = a[0][0] + x.a[0][0], c.a[0][1] = a[0][1] + x.a[0][1], c.a[0][2] = a[0][2] + x.a[0][2]; return c; } void clear2(){ n = m = 3; a[0][0] = a[0][1] = a[0][2] = a[1][0] = a[1][1] = a[1][2] = a[2][0] = a[2][1] = a[2][2] = 0; return ; } void clear(){ n = m = 3; a[0][0] = a[0][1] = a[0][2] = a[1][0] = a[1][1] = a[1][2] = a[2][0] = a[2][1] = a[2][2] = 0; a[0][0] = a[1][1] = a[2][2] = 1; return ; } void print(){ for(int i = 0; i &lt;= 2; i++){ for(int j = 0; j &lt;= 2; j++){ write(a[i][j]), put(); }endl; }endl; } }; Matrix MatrixQuickPower(Matrix a, int b, int mod){ Matrix ans = a; Matrix base = a; b--; while(b){ if(b &amp; 1) ans = ans * base; base = base * base; b &gt;&gt;= 1; } return ans; } 逆天快速gcd inline int gcd(int a, int b) {int az = __builtin_ctz(a), bz = __builtin_ctz(b), z = (az &gt; bz) ? bz : az, t; b &gt;&gt;= bz; while (a) a &gt;&gt;= az, t = a - b, az = __builtin_ctz(t), a = t &lt; 0 ? -t : t, b = a &lt; b ? a : b; return b &lt;&lt; z;} 枚举子集 for(int S = (x - 1) &amp; x; S; S = x &amp; (S - 1)) 一种不容易被卡掉的 pair 哈希 static ull splitmix64 (ull x) { // http://xorshift.di.unimi.it/splitmix64.c x += 0x9e3779b97f4a7c15; x = (x ^ (x &gt;&gt; 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x &gt;&gt; 27)) * 0x94d049bb133111eb; return x ^ (x &gt;&gt; 31); } ull safe_hash (ull x) { static const ull base = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + base); } int To(pair &lt;int, int&gt; A){ int x = A.first; int y = A.second; // return x + y; return (safe_hash(x) + safe_hash(y)) ; } ","tags":[{"name":"学习笔记","slug":"qWhunhKoya","used":true,"link":"https://WRuperD.github.io/tag/qWhunhKoya/"}],"title":" 一些模板","feature":"","link":"https://WRuperD.github.io/post/yi-xie-mo-ban/","stats":{"text":"8 min read","time":438000,"words":1184,"minutes":8},"date":"2023-11-08 11:28:52","dateFormat":"2023-11-08"},{"abstract":"","content":"数列分块入门 算是入门了吧 写在前面 本人十分之 Naive 所以写的不好还请见谅。 前置知识 暴力 线段树 线段树貌似也不太需要，但本文建立在你已经会线段树的基础上。但真有人先学分块再学线段树的嘛？ 前置思想 先插一个题外话，以下题目均在Loj上。Luogu在这方面略有欠缺。 好的，回到正题。严格来讲，分块是一种处理数据的思想，而非数据结构。 我们先从最经典的问题来一步一步了解分块： LOJ #6277. 数列分块入门 1 https://loj.ac/p/6277 来看这一道题。非常显然，这题可以用线段树秒杀，但我们要学习分块。 在线段树上，我们把区间分为了 log⁡n\\log{n}logn 个子区间，单独维护它们的信息，并且根据它们信息的可加性，维护处一整段的信息。 而分块是这样子的： 如题，我们完美的把这八个元素分成了四个块。我们可以维护每个块的信息。对于每一次查询一个区间问题，我们只需要暴力地把每个查询区间完整块内的答案加起来，再计算零散的元素的贡献，即可获得答案。 以此题为例，查询2到7的时候流程是这样的： 这东西看着就很不靠谱是吧。。。。但是如果我们把块长设为 n\\sqrt{n}n​ ，它的时间复杂度就蜕变为了 O(nn)O(n \\sqrt{n})O(nn​) 分块的时间复杂度主要取决于分块的块长，一般可以通过均值不等式求出某个问题下的最优块长，以及相应的时间复杂度。 那这东西对比线段树有什么优势呢？？？ 我个人认为，这东西与线段树，就好像树状数组与线段树。分块处理的信息并不需要满足线段可加性，但线段树是 log⁡\\loglog，分块是 \\sqrt。 到此为止，分块入门基本上就讲完了。 对于本题，细节看代码： #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn = 50005; #define int long long int a[maxn], sum[maxn], add[maxn]; int id[maxn]; int L[maxn], R[maxn]; int n, t; void addd(int l, int r, int y){ int p = id[l], q = id[r]; if(p == q){ // 如果属于一个块就暴力加 for(int i = l; i &lt;= r; i++){ a[i] += y; } sum[p] += y*(r-l+1);//记得更新当前块的和 }else{ for(int i = p+1; i &lt;= q-1; i++) add[i] += y; // 大块直接加tag for(int i = l; i &lt;= R[p]; i++) a[i] += y; // 小块暴力加 for(int i = r; i &gt;= L[q]; i--) a[i] += y; // 小块暴力加 sum[p] += y * (R[p] - l + 1);//记得更新当前块的和 sum[q] += y * (r - L[q] + 1);//记得更新当前块的和 } } signed main(){ cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i]; int t = sqrt(n); // t为块长 for(int i = 1; i &lt;= n; i++) id[i] = (i-1)/t+1; // id记录了a[i]属于哪个块 for(int i = 1; i &lt;= n; i++) sum[id[i]] += a[i];//块信息预处理 for(int i = 1; i &lt;= id[n]; i++) L[i]=(i-1)*t+1,R[i]=i*t;//L[i]为第i个块的左端点，R[i]为右端点 R[id[n]] = n;//需要特判一下最后一个块不完整的情况 for(int i = 1; i &lt;= n; i++){ int op, l, r, c; cin&gt;&gt;op&gt;&gt;l&gt;&gt;r&gt;&gt;c; if(op) cout&lt;&lt;a[r] + add[id[r]]&lt;&lt;endl; // 输出a[i] + tag else addd(l, r, c); } return 0; } LOJ #6280. 数列分块入门 4 https://loj.ac/p/6280 同上，直接看代码 #include&lt;bits/stdc++.h&gt; using namespace std; const int maxn = 50005; #define int long long int a[maxn], sum[maxn], add[maxn]; int id[maxn]; int L[maxn], R[maxn]; int n, t; void addd(int l, int r, int y){ int p = id[l], q = id[r]; if(p == q){ // 如果属于一个块就暴力加 for(int i = l; i &lt;= r; i++){ a[i] += y; } sum[p] += y*(r-l+1);//记得更新当前块的和 }else{ for(int i = p+1; i &lt;= q-1; i++) add[i] += y; // 大块直接加tag for(int i = l; i &lt;= R[p]; i++) a[i] += y; // 小块暴力加 for(int i = r; i &gt;= L[q]; i--) a[i] += y; // 小块暴力加 sum[p] += y * (R[p] - l + 1);//记得更新当前块的和 sum[q] += y * (r - L[q] + 1);//记得更新当前块的和 } } int q(int l, int r, int c){ int p = id[l], q = id[r]; int ans = 0; if(p == q){//同块直接暴力统计答案 for(int i = l; i &lt;= r; i++){ ans += a[i]; ans %= c; } ans += add[p] % c * (r-l+1) % c; ans %= c; return ans; } for(int i = p+1; i &lt;= q-1; i++){ ans += sum[i] % c + add[i] % c * (R[i] - L[i] + 1) % c; //统计中间完整块的答案 } for(int i = l; i &lt;= R[p]; i++) ans += a[i], ans %= c;//散块 for(int i = r; i &gt;= L[q]; i--) ans += a[i], ans %= c;//散块 ans += add[p] % c * (R[p] - l + 1) % c; ans %= c; ans += add[q] % c * (r - L[q] + 1) % c; ans %= c; return ans; } signed main(){ cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i]; int t = sqrt(n); // t为块长 for(int i = 1; i &lt;= n; i++) id[i] = (i-1)/t+1; // id记录了a[i]属于哪个块 for(int i = 1; i &lt;= n; i++) sum[id[i]] += a[i];//块信息预处理 for(int i = 1; i &lt;= id[n]; i++) L[i]=(i-1)*t+1,R[i]=i*t;//L[i]为第i个块的左端点，R[i]为右端点 R[id[n]] = n;//需要特判一下最后一个块不完整的情况 for(int i = 1; i &lt;= n; i++){ int op, l, r, c; cin&gt;&gt;op&gt;&gt;l&gt;&gt;r&gt;&gt;c; if(op) cout&lt;&lt;q(l, r, c+1)&lt;&lt;endl; else addd(l, r, c); } return 0; } LOJ#6278. 数列分块入门 2 有趣的题，请你确保理解了上面的题。 好的，这道题求小于 xxx 的数的个数。如果是在有序的序列，那我们肯定会做，直接二份即可。 考虑使用分块，对于每一个块，进行块内排序，即： for(int i = 1; i &lt;= t; i++){ sort(a+L[i], a+R[i]+1); } 这样子，我们就可以二分每一个块进行暴力统计，对于每一个散的元素，直接在原数组上暴力统计即可。太暴力了！ 总时间复杂度 O(nlog⁡n+nnlog⁡n)O(n\\log{n} + n\\sqrt{n}\\log{n})O(nlogn+nn​logn) 注：我的代码中b为原数组 #include&lt;bits/stdc++.h&gt; using namespace std; const int MAX = 50005; int a[MAX]; int b[MAX]; int id[MAX]; int pls[MAX]; int L[MAX], R[MAX]; void add(int l, int r, int c){ int p = id[l], q = id[r]; if(p == q){ for(int i = l; i &lt;= r; i++) b[i] += c; for(int i = L[p]; i &lt;= R[p]; i++){ a[i] = b[i]; } sort(a+L[p], a+R[p]+1); }else{ for(int i = p+1; i &lt;= q-1; i++) pls[i] += c; for(int i = l; i &lt;= R[p]; i++) b[i] += c; for(int i = L[p]; i &lt;= R[p]; i++) a[i] = b[i]; sort(a+L[p], a+R[p]+1); for(int i = r; i &gt;= L[q]; i--) b[i] += c; for(int i = L[q]; i &lt;= R[q]; i++) a[i] = b[i]; sort(a+L[q], a+R[q]+1); } } int query(int l, int r, int c){ int p = id[l], q = id[r]; if(p == q){ int ans = 0; for(int i = l; i &lt;= r; i++) if(b[i] + pls[p] &lt; c) ans++; return ans; }else{ int ans = 0; for(int i = p+1; i &lt;= q-1; i++){ int x1 = lower_bound(a+L[i], a+R[i]+1, c-pls[i]) - a - L[i]; ans += x1; } for(int i = l; i &lt;= R[p]; i++) if(b[i] + pls[p] &lt; c) ans++; for(int i = L[q]; i &lt;= r; i++) if(b[i] + pls[q] &lt; c) ans++; return ans; } } signed main(){ int n; cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i], b[i] = a[i]; int t = sqrt(n); // t为块长 for(int i = 1; i &lt;= n; i++) id[i] = (i-1)/t+1; // id记录了a[i]属于哪个块 for(int i = 1; i &lt;= id[n]; i++) L[i]=(i-1)*t+1,R[i]=i*t;//L[i]为第i个块的左端点，R[i]为右端点 R[id[n]] = n;//需要特判一下最后一个块不完整的情况 for(int i = 1; i &lt;= t; i++){ sort(a+L[i], a+R[i]+1); } for(int i = 1; i &lt;= n; i++){ int op, l, r, c; cin&gt;&gt;op&gt;&gt;l&gt;&gt;r&gt;&gt;c; if(op == 0){ add(l, r, c); }else{ cout&lt;&lt;query(l, r, c*c)&lt;&lt;endl; } } return 0; } LOJ #6279. 数列分块入门 3 同上 #include&lt;bits/stdc++.h&gt; using namespace std; static char buf[1000000],*p1=buf,*p2=buf; #define getchar() p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++ inline int read(){int x=0,f=1;char c=getchar();while(c&lt;'0' || c&gt;'9'){if(c=='-') f=-1;c=getchar();}while(c&gt;='0' &amp;&amp; c&lt;='9') {x=x*10+c-48;c=getchar();}return x*f;} inline void write(int x){static char buf[20];static int len=-1;if(x&lt;0)putchar('-'),x=-x;do buf[++len]=x%10,x/=10;while(x);while(len&gt;=0)putchar(buf[len--]+'0');} const int MAX = 1e5+10; int a[MAX]; int b[MAX]; int id[MAX]; int pls[MAX]; int L[MAX], R[MAX]; void add(int l, int r, int c){ int p = id[l], q = id[r]; if(p == q){ for(int i = l; i &lt;= r; i++) b[i] += c; for(int i = L[p]; i &lt;= R[p]; i++){ a[i] = b[i]; } sort(a+L[p], a+R[p]+1); }else{ for(int i = p+1; i &lt;= q-1; i++) pls[i] += c; for(int i = l; i &lt;= R[p]; i++) b[i] += c; for(int i = L[p]; i &lt;= R[p]; i++) a[i] = b[i]; sort(a+L[p], a+R[p]+1); for(int i = r; i &gt;= L[q]; i--) b[i] += c; for(int i = L[q]; i &lt;= R[q]; i++) a[i] = b[i]; sort(a+L[q], a+R[q]+1); } } int query(int l, int r, int c){ int p = id[l], q = id[r]; if(p == q){ int ans = -0x3f3f3f3f; for(int i = l; i &lt;= r; i++) if(b[i] + pls[p] &lt; c) ans = max(ans, b[i]+pls[p]); return ans; }else{ int ans = -0x3f3f3f3f; for(int i = p+1; i &lt;= q-1; i++){ int x1 = lower_bound(a+L[i], a+R[i]+1, c-pls[i]) - a; if(x1 == L[i]) continue; ans = max(ans, a[x1-1]+pls[i]); } for(int i = l; i &lt;= R[p]; i++) if(b[i] + pls[p] &lt; c) ans = max(ans, b[i]+pls[p]); for(int i = L[q]; i &lt;= r; i++) if(b[i] + pls[q] &lt; c) ans = max(ans, b[i]+pls[q]); return ans; } } signed main(){ int n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(), b[i] = a[i]; int t = sqrt(n); // t为块长 for(int i = 1; i &lt;= n; i++) id[i] = (i-1)/t+1; // id记录了a[i]属于哪个块 for(int i = 1; i &lt;= id[n]; i++) L[i]=(i-1)*t+1,R[i]=i*t;//L[i]为第i个块的左端点，R[i]为右端点 R[id[n]] = n;//需要特判一下最后一个块不完整的情况 for(int i = 1; i &lt;= t; i++){ sort(a+L[i], a+R[i]+1); } for(int i = 1; i &lt;= n; i++){ int op = read(), l = read(), r = read(), c = read(); if(op == 0){ add(l, r, c); }else{ int ans = query(l, r, c); if(ans == -0x3f3f3f3f) puts(&quot;-1&quot;); else write(ans), putchar('\\n'); } } return 0; } LOJ #6281. 数列分块入门 5 https://loj.ac/p/6281 双倍经验：https://www.luogu.com.cn/problem/SP2713 https://www.luogu.com.cn/problem/P4145 很巧妙的一道题。 考虑到1e12的数开6次方就变成了1，再对它进行操作就没有意义了。所以我们对于数据分块，对于每个块，如果每个数都变成了1，那就不用去操作它了。 复杂度我不太会算，大概是： O(nn)O(n\\sqrt{n})O(nn​) 的吧。不过这题稍加思考就可以用线段树代替分块实现 log⁡\\loglog 解法。 代码： #include&lt;bits/stdc++.h&gt; using namespace std; static char buf[1000000],*p1=buf,*p2=buf; #define getchar() p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++ inline int read(){int x=0,f=1;char c=getchar();while(c&lt;'0' || c&gt;'9'){if(c=='-') f=-1;c=getchar();}while(c&gt;='0' &amp;&amp; c&lt;='9') {x=x*10+c-48;c=getchar();}return x*f;} inline void write(int x){static char buf[20];static int len=-1;if(x&lt;0)putchar('-'),x=-x;do buf[++len]=x%10,x/=10;while(x);while(len&gt;=0)putchar(buf[len--]+'0');} const int maxn = 200010; #define int long long int a[maxn], sum[maxn], pls[maxn]; int id[maxn]; int L[maxn], R[maxn]; int n, t; void add(int l, int r){ int p = id[l], q = id[r]; if(p == q){ if(sum[p] == R[p]-L[p]+1) return ; for(int i = l; i &lt;= r; i++){ sum[p] -= a[i]; a[i] = sqrt(a[i]); sum[p] += a[i]; } }else{ if(sum[p] != R[p] - L[p] + 1) for(int i = l; i &lt;= R[p]; i++) sum[p] -= a[i], a[i] = sqrt(a[i]), sum[p] += a[i]; if(sum[q] != R[q] - L[q] + 1) for(int i = r; i &gt;= L[q]; i--) sum[q] -= a[i], a[i] = sqrt(a[i]), sum[q] += a[i]; for(int i = p+1; i &lt;= q-1; i++) if(sum[i] != R[i] - L[i] + 1) for(int j = L[i]; j &lt;= R[i]; j++) sum[i] -= a[j], a[j] = sqrt(a[j]), sum[i] += a[j]; } } int query(int l, int r){ int p = id[l], q = id[r]; int ans = 0; if(p == q){ for(int i = l; i &lt;= r; i++) ans += a[i]; return ans; }else{ for(int i = p+1; i &lt;= q-1; i++) ans += sum[i]; for(int i = l; i &lt;= R[p]; i++) ans += a[i]; for(int i = L[q]; i &lt;= r; i++) ans += a[i]; return ans; } } signed main(){ n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(); int t = sqrt(n); // t为块长 for(int i = 1; i &lt;= n; i++) id[i] = (i-1)/t+1; // id记录了a[i]属于哪个块 for(int i = 1; i &lt;= n; i++) sum[id[i]] += a[i];//块信息预处理 for(int i = 1; i &lt;= id[n]; i++) L[i]=(i-1)*t+1,R[i]=i*t;//L[i]为第i个块的左端点，R[i]为右端点 R[id[n]] = n;//需要特判一下最后一个块不完整的情况 for(int i = 1; i &lt;= n; i++){ int op = read(), l = read(), r = read(), c = read(); if(l &gt; r) swap(l, r); if(op) cout&lt;&lt;query(l, r)&lt;&lt;endl; else add(l, r); } return 0; } LOJ #6282. 数列分块入门 6 https://loj.ac/p/6282 挺无聊的题。直接对于数据分块，然后暴力插入。 #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long static char buf[1000000],*p1=buf,*p2=buf; #define getchar() p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++ inline int read(){int x=0,f=1;char c=getchar();while(c&lt;'0' || c&gt;'9'){if(c=='-') f=-1;c=getchar();}while(c&gt;='0' &amp;&amp; c&lt;='9') {x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48;c=getchar();}return x*f;} inline void write(int x){static char buf[20];static int len=-1;if(x&lt;0)putchar('-'),x=-x;do buf[++len]=x%10,x/=10;while(x);while(len&gt;=0)putchar(buf[len--]+48);} const int MAX = 300005; int a[MAX], id[MAX]; vector &lt;int&gt; v[MAX]; int n; void add(int x, int val){ for(int i = 1; i &lt;= id[n]; i++){ if(x &lt;= v[i].size()){ auto pos = v[i].begin(); for(int i = 1; i &lt; x; i++) pos++; v[i].insert(pos, val); return ; }else{ x -= v[i].size(); } } } int query(int x){ for(int i = 1; i &lt;= id[n]; i++){ if(x &lt;= v[i].size()) return v[i][x-1]; else x -= v[i].size(); } } signed main(){ n = read(); int t = sqrt(n); for(int i = 1; i &lt;= n; i++) a[i] = read(), id[i] = (i-1)/t+1, v[id[i]].push_back(a[i]); for(int i = 1; i &lt;= n; i++){ int op = read(), l = read(), r = read(), c = read(); if(op == 0) add(l, r); else write(query(r)), puts(&quot;&quot;); } return 0; } LOJ#6283. 数列分块入门 7 同https://www.luogu.com.cn/problem/P3373 懒得写了。。。。。 LOJ#6284. 数列分块入门 8 https://loj.ac/p/6284 区间推平？？？珂朵莉树？？？ 然而这题只需要对于每一个区间打一个修改tag即可。需要再改。 #include&lt;bits/stdc++.h&gt; using namespace std; static char buf[1000000],*p1=buf,*p2=buf; #define getchar() p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++ inline int read(){int x=0,f=1;char c=getchar();while(c&lt;'0' || c&gt;'9'){if(c=='-') f=-1;c=getchar();}while(c&gt;='0' &amp;&amp; c&lt;='9') {x=x*10+c-48;c=getchar();}return x*f;} inline void write(int x){static char buf[20];static int len=-1;if(x&lt;0)putchar('-'),x=-x;do buf[++len]=x%10,x/=10;while(x);while(len&gt;=0)putchar(buf[len--]+'0');} const int maxn = 100005; #define int long long int a[maxn], sum[maxn], pls[maxn]; int id[maxn]; int L[maxn], R[maxn]; int n, t; void add(int l, int r, int c){ int p = id[l], q = id[r]; if(p == q){ if(sum[p] != c){ if(sum[p] != 0)for(int i = L[q]; i &lt;= R[q]; i++) a[i] = sum[p]; sum[p] = 0; for(int i = l; i &lt;= r; i++) a[i] = c; } }else{ if(sum[p] != c){ if(sum[p] != 0)for(int i = L[p]; i &lt; l; i++) a[i] = sum[p]; sum[p] = 0; for(int i = l; i &lt;= R[p]; i++) a[i] = c; } if(sum[q] != c){ if(sum[q] != 0)for(int i = L[q]; i &lt;= R[q]; i++) a[i] = sum[q]; sum[q] = 0; for(int i = r; i &gt;= L[q]; i--) a[i] = c; } for(int i = p+1; i &lt;= q-1; i++) sum[i] = c; } } int query(int l, int r, int c){ int p = id[l], q = id[r]; int ans = 0; if(p == q){ if(sum[p] == c) ans += r-l+1; else if(sum[p] == 0)for(int i = l; i &lt;= r; i++) ans += a[i] == c; return ans; }else{ for(int i = p+1; i &lt;= q-1; i++){ if(sum[i] == c) ans += R[i] - L[i] + 1; else if(sum[i] == 0) for(int j = L[i]; j &lt;= R[i]; j++) ans += a[j] == c; } if(sum[p] == c){ ans += R[p] - l + 1; }else if(sum[p] == 0){ for(int i = l; i &lt;= R[p]; i++) ans += a[i] == c; } if(sum[q] == c){ ans += r - L[q] + 1; }else if(sum[q] == 0){ for(int i = L[q]; i &lt;= r; i++) ans += a[i] == c; } return ans; } } signed main(){ n = read(); for(int i = 1; i &lt;= n; i++) a[i] = read(); int t = sqrt(n); // t为块长 for(int i = 1; i &lt;= n; i++) id[i] = (i-1)/t+1; // id记录了a[i]属于哪个块 for(int i = 1; i &lt;= id[n]; i++) L[i]=(i-1)*t+1,R[i]=i*t;//L[i]为第i个块的左端点，R[i]为右端点 R[id[n]] = n;//需要特判一下最后一个块不完整的情况 for(int i = 1; i &lt;= n; i++){ int l = read(), r = read(), c = read(); write(query(l, r, c)); putchar('\\n'); add(l, r, c); } return 0; } LOJ#6285. 数列分块入门 9 重量级：https://loj.ac/p/6285 luogu：https://www.luogu.com.cn/problem/P4168 挺有意思的题目。 记 s[i][j]s[i][j]s[i][j] 为前 iii 个块元素 jjj 出现的个数。 f[i][j]f[i][j]f[i][j] 为 iii 到 jjj 块的区间最小众数。 我们惊讶地发现 sss 和 fff 均可以通过 nnn\\sqrt{n}nn​ 的时间内预处理，然后就做完了。 #include&lt;bits/stdc++.h&gt; using namespace std; static char buf[1000000],*p1=buf,*p2=buf; #define getchar() p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++ inline int read(){int x=0,f=1;char c=getchar();while(c&lt;'0' || c&gt;'9'){if(c=='-') f=-1;c=getchar();}while(c&gt;='0' &amp;&amp; c&lt;='9') {x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48;c=getchar();}return x*f;} inline void write(int x){static char buf[20];static int len=-1;if(x&lt;0)putchar('-'),x=-x;do buf[++len]=x%10,x/=10;while(x);while(len&gt;=0)putchar(buf[len--]+48);} const int MAX = 50005; const int MAX2 = 300; int n, m; int n2, num, t2; int a[MAX], b[MAX]; int id[MAX], L[MAX], R[MAX]; int s[MAX2][MAX], f[MAX2][MAX2]; int t[MAX]; int query(int l, int r){ int p = id[l], q = id[r]; int ans = 0; if(p == q){ for(int i = l; i &lt;= r; i++) t[a[i]]++; for(int i = l; i &lt;= r; i++) if(t[a[i]] &gt; t[ans] or (t[a[i]] == t[ans] and a[i] &lt; ans)) ans = a[i]; for(int i = l; i &lt;= r; i++) t[a[i]] = 0; }else{ ans = f[p+1][q-1]; for(int i = l; i &lt;= R[p]; i++) t[a[i]]++; for(int i = L[q]; i &lt;= r; i++) t[a[i]]++; for(int i = l; i &lt;= R[p]; i++){ int temp = s[q-1][a[i]] - s[p][a[i]] + t[a[i]], anss = s[q-1][ans] - s[p][ans] + t[ans]; if(temp &gt; anss or (temp == anss and ans &gt; a[i])) ans = a[i]; } for(int i = L[q]; i &lt;= r; i++){ int temp = s[q-1][a[i]] - s[p][a[i]] + t[a[i]], anss = s[q-1][ans] - s[p][ans] + t[ans]; if(temp &gt; anss or (temp == anss and ans &gt; a[i])) ans = a[i]; } for(int i = l; i &lt;= R[p]; i++) t[a[i]] = 0; for(int i = L[q]; i &lt;= r; i++) t[a[i]] = 0; } return ans; } int main(){ n = read(), m = read(); for(int i = 1; i &lt;= n; i++) b[i] = a[i] = read(); t2 = sqrt(n); for(int i = 1; i &lt;= n; i++) id[i] = (i-1)/t2+1; for(int i = 1; i &lt;= id[n]; i++) L[i] = (i-1)*t2+1, R[i] = i*t2; R[id[n]] = n; sort(b+1, b+n+1); n2 = unique(b+1, b+n+1) - b - 1; for(int i = 1; i &lt;= n; i++) a[i] = lower_bound(b+1, b+n2+1, a[i]) - b; num = id[n]; for(int i = 1; i &lt;= num; i++){ for(int j = L[i]; j &lt;= R[i]; j++) s[i][a[j]]++; for(int j = 1; j &lt;= n2; j++) s[i][j] += s[i-1][j]; } for(int i = 1; i &lt;= num; i++){ for(int j = i; j &lt;= num; j++){ int maxn = f[i][j-1]; for(int k = L[j]; k &lt;= R[j]; k++){ if(s[j][a[k]] - s[i-1][a[k]] &gt; s[j][maxn] - s[i-1][maxn] or (s[j][a[k]] - s[i-1][a[k]] == s[j][maxn] - s[i-1][maxn] and a[k] &lt; maxn)){ maxn = a[k]; } } f[i][j] = maxn; } } int last = 0; for(int i = 1; i &lt;= m; i++){ int l = ((read() + last - 1) % n) + 1, r = ((read() + last - 1) % n) + 1; if(l &gt; r) swap(l, r); int ans = query(l, r); write(b[ans]); last = b[ans]; puts(&quot;&quot;); } return 0; } Ex练习 luogu P4135 作诗 类似蒲公英 点击查看代码 #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long static char buf[1000000],*p1=buf,*p2=buf; #define getchar() p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++ inline int read(){int x=0,f=1;char c=getchar();while(c&lt;'0' || c&gt;'9'){if(c=='-') f=-1;c=getchar();}while(c&gt;='0' &amp;&amp; c&lt;='9') {x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48;c=getchar();}return x*f;} inline void write(int x){static char buf[20];static int len=-1;if(x&lt;0)putchar('-'),x=-x;do buf[++len]=x%10,x/=10;while(x);while(len&gt;=0)putchar(buf[len--]+48);} const int MAX = 100005; const int MAX2 = 400; int n, m; int n2, num, t2; int a[MAX], b[MAX]; int id[MAX], L[MAX], R[MAX]; int s[MAX2][MAX], f[MAX2][MAX2]; int t[MAX]; bool vis[MAX]; int query(int l, int r){ int p = id[l], q = id[r]; int ans = 0; if(p == q){ for(int i = l; i &lt;= r; i++) t[a[i]]++; for(int i = l; i &lt;= r; i++){ if(vis[a[i]]) continue; if(t[a[i]] % 2 == 0) ans++; vis[a[i]] = 1; } for(int i = l; i &lt;= r; i++) t[a[i]] = 0, vis[a[i]] = 0; }else{ ans = f[p+1][q-1]; for(int i = l; i &lt;= R[p]; i++) t[a[i]]++; for(int i = L[q]; i &lt;= r; i++) t[a[i]]++; for(int i = l; i &lt;= R[p]; i++){ if(vis[a[i]]) continue; int temp = s[q-1][a[i]] - s[p][a[i]] + t[a[i]]; int pre = s[q-1][a[i]] - s[p][a[i]]; if(vis[a[i]]) continue; if(temp % 2 == 1 and pre % 2 == 0 and temp &gt; 0 and pre &gt; 0) ans--; if(temp % 2 == 0 and pre % 2 == 1 and temp &gt; 0 and pre &gt; 0) ans++; if(temp % 2 == 0 and pre == 0 and temp &gt; 0) ans++; vis[a[i]] = 1; } for(int i = L[q]; i &lt;= r; i++){ if(vis[a[i]]) continue; int temp = s[q-1][a[i]] - s[p][a[i]] + t[a[i]]; int pre = s[q-1][a[i]] - s[p][a[i]]; if(temp % 2 == 1 and pre % 2 == 0 and temp &gt; 0 and pre &gt; 0) ans--; if(temp % 2 == 0 and pre % 2 == 1 and temp &gt; 0 and pre &gt; 0) ans++; if(temp % 2 == 0 and pre == 0 and temp &gt; 0) ans++; vis[a[i]] = 1; } for(int i = l; i &lt;= R[p]; i++) t[a[i]] = 0, vis[a[i]] = 0; for(int i = L[q]; i &lt;= r; i++) t[a[i]] = 0, vis[a[i]] = 0; } return ans; } signed main(){ int rub; n = read(), rub = read(), m = read(); for(int i = 1; i &lt;= n; i++) b[i] = a[i] = read(); t2 = sqrt(n); for(int i = 1; i &lt;= n; i++) id[i] = (i-1)/t2+1; for(int i = 1; i &lt;= id[n]; i++) L[i] = (i-1)*t2+1, R[i] = i*t2; R[id[n]] = n; sort(b+1, b+n+1); n2 = unique(b+1, b+n+1) - b - 1; for(int i = 1; i &lt;= n; i++) a[i] = lower_bound(b+1, b+n2+1, a[i]) - b; num = id[n]; for(int i = 1; i &lt;= num; i++){ for(int j = L[i]; j &lt;= R[i]; j++) s[i][a[j]]++; for(int j = 1; j &lt;= n2; j++) s[i][j] += s[i-1][j]; } for(int i = 1; i &lt;= num; i++){ for(int j = i; j &lt;= num; j++){ int ans = f[i][j-1]; for(int k = L[j]; k &lt;= R[j]; k++){ if(vis[a[k]]) continue; if((s[j][a[k]] - s[i-1][a[k]]) % 2 == 0 and (s[j-1][a[k]] - s[i-1][a[k]]) % 2 == 1 and (s[j][a[k]] - s[i-1][a[k]]) &gt; 0 and (s[j-1][a[k]] - s[i-1][a[k]]) &gt; 0) ans++; if((s[j][a[k]] - s[i-1][a[k]]) % 2 == 1 and (s[j-1][a[k]] - s[i-1][a[k]]) % 2 == 0 and (s[j][a[k]] - s[i-1][a[k]]) &gt; 0 and (s[j-1][a[k]] - s[i-1][a[k]]) &gt; 0) ans--; if((s[j][a[k]] - s[i-1][a[k]]) % 2 == 0 and (s[j-1][a[k]] - s[i-1][a[k]]) == 0 and (s[j][a[k]] - s[i-1][a[k]]) &gt; 0) ans++; vis[a[k]]=1; } for(int k = L[j]; k &lt;= R[j]; k++) vis[a[k]] = 0; f[i][j] = ans; } } int last = 0; for(int i = 1; i &lt;= m; i++){ int l = ((read() + last) % n) + 1, r = ((read() + last) % n) + 1; if(l &gt; r) swap(l, r); int ans = query(l, r); write(ans); last = ans; puts(&quot;&quot;); } return 0; } P5048 [Ynoi2019 模拟赛] Yuno loves sqrt technology III 更优美的求区间众数 点击查看代码 #include&lt;bits/stdc++.h&gt; using namespace std; #define int long long static char buf[1000000],*p1=buf,*p2=buf; #define getchar() p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++ inline int read(){int x=0,f=1;char c=getchar();while(c&lt;'0' || c&gt;'9'){if(c=='-') f=-1;c=getchar();}while(c&gt;='0' &amp;&amp; c&lt;='9') {x=(x&lt;&lt;3)+(x&lt;&lt;1)+c-48;c=getchar();}return x*f;} inline void write(int x){static char buf[20];static int len=-1;if(x&lt;0)putchar('-'),x=-x;do buf[++len]=x%10,x/=10;while(x);while(len&gt;=0)putchar(buf[len--]+48);} const int MAX = 500005; const int MAX2 = 720; int n, m; int n2, num, t2; int a[MAX], b[MAX]; int id[MAX], L[MAX], R[MAX]; int f[MAX2][MAX2]; int cnt[MAX]; vector &lt;int&gt; v[MAX]; int pos[MAX]; int t[MAX]; int query(int l, int r){ int p = id[l], q = id[r]; int ans = 0; int re = 0; if(p == q){ for(int i = l; i &lt;= r; i++) t[a[i]]++; for(int i = l; i &lt;= r; i++) if(t[a[i]] &gt; t[ans] or (t[a[i]] == t[ans] and a[i] &lt; ans)) ans = a[i]; re = t[ans]; for(int i = l; i &lt;= r; i++) t[a[i]] = 0; }else{ ans = f[p+1][q-1]; for(int i = l; i &lt;= R[p]; i++){ int now = pos[i] + ans; while(now &lt; v[a[i]].size() and v[a[i]][now] &lt;= r) ans++, now++; } for(int i = L[q]; i &lt;= r; i++){ int now = pos[i] - ans; while(now &gt;= 0 and v[a[i]][now] &gt;= l) ans++, now--; } re = ans; } return re; } signed main(){ n = read(), m = read(); for(int i = 1; i &lt;= n; i++) b[i] = a[i] = read(); t2 = sqrt(n); for(int i = 1; i &lt;= n; i++) id[i] = (i-1)/t2+1; for(int i = 1; i &lt;= id[n]; i++) L[i] = (i-1)*t2+1, R[i] = i*t2; R[id[n]] = n; sort(b+1, b+n+1); n2 = unique(b+1, b+n+1) - b - 1; for(int i = 1; i &lt;= n; i++) a[i] = lower_bound(b+1, b+n2+1, a[i]) - b, v[a[i]].push_back(i), pos[i] = v[a[i]].size()-1; num = id[n]; for(int i = 1; i &lt;= num; i++){ memset(cnt, 0, sizeof(cnt)); for(int j = i; j &lt;= num; j++){ f[i][j] = f[i][j-1]; for(int k = L[j]; k &lt;= R[j]; k++){ cnt[a[k]]++; f[i][j] = max(f[i][j], cnt[a[k]]); } } } int last = 0; for(int i = 1; i &lt;= m; i++){ int l = read() xor last, r = read() xor last; if(l &gt; r) swap(l, r); int ans = query(l, r); write(ans); last = ans; puts(&quot;&quot;); } return 0; } P5356 [Ynoi2017] 由乃打扑克 -&gt; 题解https://www.cnblogs.com/WRuperD/p/16725324.html ","tags":[{"name":"学习笔记","slug":"qWhunhKoya","used":true,"link":"https://WRuperD.github.io/tag/qWhunhKoya/"}],"title":"数列分块入门","feature":"","link":"https://WRuperD.github.io/post/shu-lie-fen-kuai-ru-men/","stats":{"text":"37 min read","time":2174000,"words":6433,"minutes":37},"date":"2022-09-30 23:25:18","dateFormat":"2022-09-30"}]}
